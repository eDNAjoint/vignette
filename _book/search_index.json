[["index.html", "eDNAjoint: an R package for interpreting paired or semi-paired environmental DNA and traditional survey data in a Bayesian framework Chapter 1 Introduction", " eDNAjoint: an R package for interpreting paired or semi-paired environmental DNA and traditional survey data in a Bayesian framework Chapter 1 Introduction This vignette provides examples and use cases of functions in the eDNAjoint package, as well as more details about the model that can be fit with eDNAjoint. The primary purpose of the joint model is to use observations from both environmental DNA (eDNA) surveys and traditional surveys (i.e., seine sampling, trap sampling, etc.) to understand the relative sensitivities of the two survey types. The model uses both streams to data to jointly estimate parameters like expected catch rate, \\(\\mu\\), at a site and false positive probability of eDNA detection, \\(p_{10}\\). The model is intended for use with with replicated, paired or semi-paired eDNA (binary, detection/non-detection) and traditional (count or continuous) observations at multiple sites across the landscape. The main functionality in eDNAjoint is the use of jointModel() that will fit the model to data. Further functions like jointSummarize() and detectionCalculate() can be used to help with model fit interpretation. This vignette contains detailed descriptions of four use cases of eDNAjoint: Use case 1: basic use of jointModel() with paired eDNA and traditional samples Use case 2: jointModel() with site-level covariates scale the sensitivity of eDNA sampling relative to traditional surveys Use case 3: jointModel() here multiple traditional gear types are used Use case 4: jointModel() with semi-paired eDNA and traditional samples (i.e., most sites have paired samples, yet some sites have only eDNA samples) Below is a summary table of all parameters estimated by the model. More information about the model can be found in the model description. Table 1.1: Parameters included in joint model, including symbols, names, and descriptions. symbol name description \\(\\mu_{i,k}\\) mu Vector of expected catch rate at site, i. If multiple traditional gear types are used, mu is an array of expected catch rate at site, i, with gear type, k. \\(p_{10}\\) p10 Probability of false positive eDNA detection \\(q_k\\) q Vector of gear scaling coefficients for traditional gear type, k. \\(\\beta\\) beta Parameter that scales the sensitivity of eDNA relative to traditional sampling. If site-level covariates are used, \\(β\\) is a vector of length, i, and a function of \\(α_n\\). If site-level covariates are not used, \\(β\\) is a scalar. \\(\\alpha_n\\) alpha Vector of regression coefficients for site-level covariates that scale the sensitivity of eDNA sampling relative to traditional sampling. Note \\(α_1\\) refers to the regression intercept. \\(\\phi\\) phi Overdispersion parameter in negative binomial distribution, if used. "],["installation.html", "Chapter 2 Installation", " Chapter 2 Installation The most stable version of eDNAjoint can be found on Cran: install.packages(&quot;eDNAjoint&quot;) You can also install the development version of eDNAjoint from ROpenSci: install.packages(&quot;eDNAjoint&quot;, repos = &quot;https://ropensci.r-universe.dev&quot;) "],["usecase1.html", "Chapter 3 Use case 1: basic use of jointModel() 3.1 Prepare the data 3.2 Fit the model 3.3 Model selection 3.4 Interpret the output 3.5 Prior sensitivity analysis 3.6 Initial values", " Chapter 3 Use case 1: basic use of jointModel() This first use case will show how to fit and interpret the joint model with paired eDNA and traditional survey data. The data used in this example comes from a study by Schmelzle and Kinziger (2016) about endangered tidewater gobies (Eucyclogobius newberryi) in California. Environmental DNA samples were collected at 39 sites, along with paired traditional seine sampling. The eDNA data is detection/non-detection data generated through quantitative polymerase chain reaction (qPCR). 3.1 Prepare the data Both eDNA and traditional survey data should have a hierarchical structure: Sites (primary sample units) within a study area eDNA and traditional samples (secondary sample units) collected from each site eDNA subsamples (replicate observations) taken from each eDNA sample Ensuring that your data is formatted correctly is essential for successfully using eDNAjoint. Let’s first explore the structure of the goby data. library(eDNAjoint) data(gobyData) str(gobyData) ## List of 4 ## $ qPCR.N : num [1:39, 1:22] 6 6 6 6 6 6 6 6 6 6 ... ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : NULL ## .. ..$ : chr [1:22] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ qPCR.K : num [1:39, 1:22] 0 0 0 0 6 0 0 0 0 5 ... ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : NULL ## .. ..$ : chr [1:22] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ count : int [1:39, 1:22] 0 0 0 0 0 0 0 0 0 1 ... ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : NULL ## .. ..$ : chr [1:22] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ site.cov: num [1:39, 1:5] -0.711 -0.211 -1.16 -0.556 -0.988 ... ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : NULL ## .. ..$ : chr [1:5] &quot;Salinity&quot; &quot;Filter_time&quot; &quot;Other_fishes&quot; &quot;Hab_size&quot; ... You can see that the data is a list of four matrices all with the same number of rows that represent each site (n=39). Across all matrices, rows in the data should correspond to the same sites (i.e., row one in all matrices corresponds to site one, and row 31 in all matrices corresponds to site 31). qPCR.K, qPCR.N, and count are required for all implementations of jointModel(), and site.cov is optional and will be used in use case 2. Let’s look first at qPCR.K. These are the total number of positive qPCR detections for each site (row) and eDNA sample (column). The number of columns should equal the maximum number of eDNA samples collected at any site. Blank spaces are filled with NA at sites where fewer eDNA samples were collected than the maximum. For example, at site one, 11 eDNA samples were collected, and at site five, 20 eDNA samples were collected. head(gobyData$qPCR.K) ## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ## [1,] 0 0 0 0 0 0 0 0 0 0 0 NA NA NA NA NA NA NA NA NA NA NA ## [2,] 0 0 0 0 0 0 0 0 0 0 0 NA NA NA NA NA NA NA NA NA NA NA ## [3,] 0 0 0 0 0 0 0 0 0 0 0 NA NA NA NA NA NA NA NA NA NA NA ## [4,] 0 6 6 4 6 5 4 6 5 3 NA NA NA NA NA NA NA NA NA NA NA NA ## [5,] 6 6 4 6 6 6 5 4 2 2 0 6 5 5 6 6 6 5 5 4 NA NA ## [6,] 0 0 0 NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA Now let’s look at qPCR.N. These are the total number of qPCR eDNA subsamples (replicate observations) collected for each site (row) and eDNA sample (column). In this data, six qPCR replicate observations were collected for each eDNA sample. Notice that the locations of the NAs in the matrix match qPCR.K. head(gobyData$qPCR.N) ## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ## [1,] 6 6 6 6 6 6 6 6 6 6 6 NA NA NA NA NA NA NA NA NA NA NA ## [2,] 6 6 6 6 6 6 6 6 6 6 6 NA NA NA NA NA NA NA NA NA NA NA ## [3,] 6 6 6 6 6 6 6 6 6 6 6 NA NA NA NA NA NA NA NA NA NA NA ## [4,] 6 6 6 6 6 6 6 6 6 6 NA NA NA NA NA NA NA NA NA NA NA NA ## [5,] 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 NA NA ## [6,] 6 6 6 NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA Next, let’s look at count. This data is from seine sampling for tidewater gobies. Each integer refers to the catch of each seine sample (i.e., catch per unit effort, when effort = 1). Again, the rows correspond to sites, and the columns refer to replicated seine samples (secondary sample units) at each site, with a maximum of 22 samples. Blank spaces are filled with NA at sites where fewer seine samples were collected than the maximum. In this example, the count data are integers, but continuous values can be used in the model (see Eq. 1.3 in the model description). head(gobyData$count) ## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ## [1,] 0 0 0 0 0 0 0 0 0 0 0 NA NA NA NA NA NA NA NA NA NA NA ## [2,] 0 0 0 0 0 0 0 0 0 0 0 NA NA NA NA NA NA NA NA NA NA NA ## [3,] 0 0 0 0 0 0 0 0 0 0 0 NA NA NA NA NA NA NA NA NA NA NA ## [4,] 0 4 1 0 2 1 38 112 1 15 NA NA NA NA NA NA NA NA NA NA NA NA ## [5,] 0 0 0 2 0 0 0 0 0 0 0 0 4 1 0 2 0 8 NA NA NA NA ## [6,] 0 0 0 NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA 3.1.1 Converting data from long to wide Using eDNAjoint requires your data to be in “wide” format. Wide vs. long data refers to the shape of your data in tidyverse jargon (see more here). Below is an example for how to convert your data to wide format. First let’s simulate “long” qPCR data. ## data dimensions # number of sites (primary sample units) nsite &lt;- 4 # number of eDNA samples (secondary sample units) neDNA_samples &lt;- 6 # number of traditional samples (secondary sample units) ntraditional_subsamples &lt;- 8 # number of eDNA subsamples (replicate observations) neDNA_subsamples &lt;- 3 # simulate qPCR data qPCR_long &lt;- data.frame( site = rep(1:nsite, each = neDNA_samples), eDNA_sample = rep(1:neDNA_samples, times = nsite), N = rep(neDNA_subsamples, nsite*neDNA_samples), K = c( rbinom(neDNA_samples, neDNA_subsamples, 0.1), # site 1 positive detections rbinom(neDNA_samples, neDNA_subsamples, 0.6), # site 2 positive detections rbinom(neDNA_samples, neDNA_subsamples, 0), # site 3 positive detections rbinom(neDNA_samples, neDNA_subsamples, 0.4) # site 4 positive detections ) ) head(qPCR_long) ## site eDNA_sample N K ## 1 1 1 3 0 ## 2 1 2 3 0 ## 3 1 3 3 0 ## 4 1 4 3 1 ## 5 1 5 3 0 ## 6 1 6 3 1 And simulate “long” traditional data: # simulate traditional count data count_long &lt;- data.frame( site = rep(1:nsite, each = ntraditional_subsamples), traditional_sample = rep(1:ntraditional_subsamples, times = nsite), count = c( rpois(ntraditional_subsamples, 0.5), # site 1 count data rpois(ntraditional_subsamples, 4), # site 2 count data rpois(ntraditional_subsamples, 0), # site 3 count data rpois(ntraditional_subsamples, 2) # site 4 count data ) ) head(count_long) ## site traditional_sample count ## 1 1 1 1 ## 2 1 2 0 ## 3 1 3 1 ## 4 1 4 1 ## 5 1 5 0 ## 6 1 6 1 Now let’s convert the data from “long” to “wide”. library(tidyverse) # N: number of qPCR eDNA subsamples (i.e., replicate observations) # per eDNA sample (i.e., secondary sample) qPCR_N_wide &lt;- qPCR_long %&gt;% pivot_wider(id_cols=site, names_from=eDNA_sample, values_from=N) %&gt;% arrange(site) %&gt;% select(-site) # K: number of positive qPCR detections in each # eDNA sample (i.e., secondary sample) qPCR_K_wide &lt;- qPCR_long %&gt;% pivot_wider(id_cols=site, names_from=eDNA_sample, values_from=K) %&gt;% arrange(site) %&gt;% select(-site) # count: number of individuals in each traditional sample # (i.e., secondary sample) count_wide &lt;- count_long %&gt;% pivot_wider(id_cols=site, names_from=traditional_sample, values_from=count) %&gt;% arrange(site) %&gt;% select(-site) Finally, we’ll bundle this data up into a named list of matrices. data &lt;- list( qPCR.N = as.matrix(qPCR_N_wide), qPCR.K = as.matrix(qPCR_K_wide), count = as.matrix(count_wide) ) 3.2 Fit the model Now that we understand our data, let’s fit the joint model. The key arguments of this function include: data: list of qPCR.K, qPCR.N, and count matrices family: probability distribution used to model the seine count data. A poisson distribution is chosen here. p10priors: Beta distribution parameters for the prior on the probability of false positive eDNA detection, \\(p_{10}\\). c(1,20) is the default specification. More on this later. q: logical value indicating the presence of multiple traditional gear types. Here, we’re only using data from one traditional method. More parameters exist to further customize the MCMC sampling, but we’ll stick with the defaults. # run the joint model goby.fit1 &lt;- jointModel(data = gobyData, family = &#39;poisson&#39;, p10priors = c(1,20), q=FALSE) goby.fit1 is a list containing: model fit (goby.fit1$model) of the class ‘stanfit’ and can be accessed and interpreted using all functions in the rstan package. initial values used for each chain in MCMC (goby.fit1$inits) 3.3 Model selection We previously made a choice to use a poisson distribution to describe the count data. This distribution assumes that the mean equals variance for count data at each site. Perhaps we want to test how that model specification compares to a model specification using a negative binomial distribution, which allows the variance of the count data to be greater than the mean. # fit a new model with negative binomial distribution goby.fit2 &lt;- jointModel(data = gobyData, family = &#39;negbin&#39;, p10priors = c(1,20), q=FALSE) We can now compare the fit of these model to our data using the jointSelect() function, which performs leave-one-out cross validation with functions from the loo package. # perform model selection jointSelect(modelfits = list(goby.fit1$model, goby.fit2$model)) ## elpd_diff se_diff ## model2 0.0 0.0 ## model1 -2339.4 619.9 These results tell us that model1 has a higher Bayesian LOO estimate of the expected log pointwise predictive density (elpd_loo). This means that goby.fit1 is likely a better fit to the data. 3.4 Interpret the output 3.4.1 Summarize posterior distributions Let’s interpret goby.fit1. Use jointSummarize() to see the posterior summaries of the model parameters. jointSummarize(goby.fit1$model, par = c(&#39;p10&#39;,&#39;beta&#39;)) ## mean se_mean sd 2.5% 97.5% n_eff Rhat ## p10 0.002 0.000 0.001 0.001 0.003 16629.35 1 ## beta 0.657 0.001 0.094 0.472 0.842 12362.86 1 This summarizes the mean, sd, and quantiles of the posterior estimates of \\(p_{10}\\) and \\(\\beta\\), as well as the effective sample size (n_eff) and Rhat for the parameters. The mean estimated probability of a false positive eDNA detection is 0.001. \\(\\beta\\) is the parameter that scales the sensitivity between eDNA and traditional sampling. We can also use functions from the bayesplot package to examine the posterior distributions and chain convergence. First let’s look at the posterior distribution for \\(p_{10}\\). library(bayesplot) # plot posterior distribution, highlighting median and 80% credibility interval mcmc_areas(as.matrix(goby.fit1$model), pars = &#39;p10&#39;, prob = 0.8) Next let’s look at chain convergence for \\(p_{10}\\) and \\(\\mu_{i=1}\\). # this will plot the MCMC chains for p10 and mu at site 1 mcmc_trace(rstan::extract(goby.fit1$model, permuted = FALSE), pars = c(&#39;p10&#39;, &#39;mu[1]&#39;)) 3.4.2 Effort necessary to detect presence To further highlight the relative sensitivity of eDNA and traditional sampling, we can use detectionCalculate() to find the units of survey effort necessary to detect presence of the species. Here, detecting presence refers to producing at least one true positive eDNA detection or catching at least one individual in a traditional survey. This function is finding the median number of survey units necessary to detect species presence if the expected catch rate, \\(\\mu\\) is 0.1, 0.5, or 1. detectionCalculate(goby.fit1$model, mu=c(0.1,0.5,1), probability = 0.9) ## mu n_traditional n_eDNA ## [1,] 0.1 24 16 ## [2,] 0.5 5 4 ## [3,] 1.0 3 2 We can also plot these comparisons. mu.min and mu.max define the x-axis in the plot. detectionPlot(goby.fit1$model, mu.min=0.1, mu.max =1, probability = 0.9) 3.4.3 Calculate \\(\\mu_{critical}\\) The probability of a true positive eDNA detection, \\(p_{11}\\), is a function of the expected catch rate, \\(\\mu\\). Low values of \\(\\mu\\) correspond to low probability of eDNA detection. Since the probability of a false-positive eDNA detection is non-zero, the probability of a false positive detection may be higher than the probability of a true positive detection at very low values of \\(\\mu\\). \\(\\mu_{critical}\\) describes the value of \\(\\mu\\) where the probability of a false positive eDNA detection equals the probability of a true positive eDNA detection. This value can be calculated using muCritical(). muCritical(goby.fit1$model, ci = 0.9) ## $median ## [1] 0.002958105 ## ## $lower_ci ## Highest Density Interval: 1.13e-03 ## ## $upper_ci ## Highest Density Interval: 5.19e-03 This function calculates \\(\\mu_{critical}\\) using the entire posterior distributions of parameters from the model, and ‘HDI’ corresponds to the 90% credibility interval calculated using the highest density interval. 3.5 Prior sensitivity analysis The previous model implementation used default values for the beta prior distribution for \\(p_{10}\\). The choice of these prior parameters can impose undue influence on the model’s inference. The best way to investigate this is to perform a prior sensitivity analysis. Let’s look at how three prior choices affect the posterior estimates of \\(p_{10}\\) and \\(\\beta\\). Prior choice 1: default prior parameters c(1,20). The mean and sd of this prior distribution are 0.048 and 0.045, respectively. fit.prior.1 &lt;- goby.fit1$model jointSummarize(fit.prior.1, par = c(&#39;p10&#39;,&#39;beta&#39;)) ## mean se_mean sd 2.5% 97.5% n_eff Rhat ## p10 0.002 0.000 0.001 0.001 0.003 16629.35 1 ## beta 0.657 0.001 0.094 0.472 0.842 12362.86 1 Prior choice 2: c(1,15). The mean and sd of this prior distribution are 0.063 and 0.058, respectively. fit.prior.2 &lt;- jointModel(data = gobyData, family = &#39;poisson&#39;, p10priors = c(1,15), q=FALSE) jointSummarize(fit.prior.2$model, par = c(&#39;p10&#39;,&#39;beta&#39;)) ## mean se_mean sd 2.5% 97.5% n_eff Rhat ## p10 0.002 0.000 0.001 0.001 0.003 18783.13 1 ## beta 0.661 0.001 0.095 0.476 0.845 10833.95 1 Prior choice 3: c(1,10). The mean and sd of this prior distribution are 0.091 and 0.083, respectively. fit.prior.3 &lt;- jointModel(data = gobyData, family = &#39;poisson&#39;, p10priors = c(1,10), q=FALSE) jointSummarize(fit.prior.3$model, par = c(&#39;p10&#39;,&#39;beta&#39;)) ## mean se_mean sd 2.5% 97.5% n_eff Rhat ## p10 0.002 0.000 0.001 0.001 0.004 16410.58 1 ## beta 0.669 0.001 0.094 0.487 0.854 10486.92 1 You can see that the choice of the \\(p_{10}\\) prior within this range has little influence on the estimated parameters. 3.6 Initial values By default, eDNAjoint will provide initial values for parameters estimated by the model, but you can provide your own initial values if you prefer. Here is an example of providing initial values for parameters, mu,p10, and beta, as an input in jointModel(). # set number of chains n.chain &lt;- 4 # initial values should be a list of named lists inits &lt;- list() for(i in 1:n.chain){ inits[[i]] &lt;- list( # length should equal the number of sites (dim(gobyData$count)[1]) for each chain mu = stats::runif(dim(gobyData$count)[1], 0.01, 5), # length should equal 1 for each chain p10 = stats::runif(1,0.0001,0.08), # length should equal 1 for each chain beta = stats::runif(1,0.05,0.2) ) } # now fit the model fit.w.inits &lt;- jointModel(data = gobyData, initial_values = inits) ## ## SAMPLING FOR MODEL &#39;joint_binary_pois&#39; NOW (CHAIN 1). ## Chain 1: ## Chain 1: Gradient evaluation took 0.000175 seconds ## Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 1.75 seconds. ## Chain 1: Adjust your expectations accordingly! ## Chain 1: ## Chain 1: ## Chain 1: Iteration: 1 / 3000 [ 0%] (Warmup) ## Chain 1: Iteration: 500 / 3000 [ 16%] (Warmup) ## Chain 1: Iteration: 501 / 3000 [ 16%] (Sampling) ## Chain 1: Iteration: 1000 / 3000 [ 33%] (Sampling) ## Chain 1: Iteration: 1500 / 3000 [ 50%] (Sampling) ## Chain 1: Iteration: 2000 / 3000 [ 66%] (Sampling) ## Chain 1: Iteration: 2500 / 3000 [ 83%] (Sampling) ## Chain 1: Iteration: 3000 / 3000 [100%] (Sampling) ## Chain 1: ## Chain 1: Elapsed Time: 1.941 seconds (Warm-up) ## Chain 1: 4.359 seconds (Sampling) ## Chain 1: 6.3 seconds (Total) ## Chain 1: ## ## SAMPLING FOR MODEL &#39;joint_binary_pois&#39; NOW (CHAIN 2). ## Chain 2: ## Chain 2: Gradient evaluation took 0.000165 seconds ## Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 1.65 seconds. ## Chain 2: Adjust your expectations accordingly! ## Chain 2: ## Chain 2: ## Chain 2: Iteration: 1 / 3000 [ 0%] (Warmup) ## Chain 2: Iteration: 500 / 3000 [ 16%] (Warmup) ## Chain 2: Iteration: 501 / 3000 [ 16%] (Sampling) ## Chain 2: Iteration: 1000 / 3000 [ 33%] (Sampling) ## Chain 2: Iteration: 1500 / 3000 [ 50%] (Sampling) ## Chain 2: Iteration: 2000 / 3000 [ 66%] (Sampling) ## Chain 2: Iteration: 2500 / 3000 [ 83%] (Sampling) ## Chain 2: Iteration: 3000 / 3000 [100%] (Sampling) ## Chain 2: ## Chain 2: Elapsed Time: 1.904 seconds (Warm-up) ## Chain 2: 4.786 seconds (Sampling) ## Chain 2: 6.69 seconds (Total) ## Chain 2: ## ## SAMPLING FOR MODEL &#39;joint_binary_pois&#39; NOW (CHAIN 3). ## Chain 3: ## Chain 3: Gradient evaluation took 8.1e-05 seconds ## Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.81 seconds. ## Chain 3: Adjust your expectations accordingly! ## Chain 3: ## Chain 3: ## Chain 3: Iteration: 1 / 3000 [ 0%] (Warmup) ## Chain 3: Iteration: 500 / 3000 [ 16%] (Warmup) ## Chain 3: Iteration: 501 / 3000 [ 16%] (Sampling) ## Chain 3: Iteration: 1000 / 3000 [ 33%] (Sampling) ## Chain 3: Iteration: 1500 / 3000 [ 50%] (Sampling) ## Chain 3: Iteration: 2000 / 3000 [ 66%] (Sampling) ## Chain 3: Iteration: 2500 / 3000 [ 83%] (Sampling) ## Chain 3: Iteration: 3000 / 3000 [100%] (Sampling) ## Chain 3: ## Chain 3: Elapsed Time: 2.29 seconds (Warm-up) ## Chain 3: 4.291 seconds (Sampling) ## Chain 3: 6.581 seconds (Total) ## Chain 3: ## ## SAMPLING FOR MODEL &#39;joint_binary_pois&#39; NOW (CHAIN 4). ## Chain 4: ## Chain 4: Gradient evaluation took 8.8e-05 seconds ## Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0.88 seconds. ## Chain 4: Adjust your expectations accordingly! ## Chain 4: ## Chain 4: ## Chain 4: Iteration: 1 / 3000 [ 0%] (Warmup) ## Chain 4: Iteration: 500 / 3000 [ 16%] (Warmup) ## Chain 4: Iteration: 501 / 3000 [ 16%] (Sampling) ## Chain 4: Iteration: 1000 / 3000 [ 33%] (Sampling) ## Chain 4: Iteration: 1500 / 3000 [ 50%] (Sampling) ## Chain 4: Iteration: 2000 / 3000 [ 66%] (Sampling) ## Chain 4: Iteration: 2500 / 3000 [ 83%] (Sampling) ## Chain 4: Iteration: 3000 / 3000 [100%] (Sampling) ## Chain 4: ## Chain 4: Elapsed Time: 1.923 seconds (Warm-up) ## Chain 4: 4.338 seconds (Sampling) ## Chain 4: 6.261 seconds (Total) ## Chain 4: ## Refer to the eDNAjoint guide for visualization tips: https://bookdown.org/abigailkeller/eDNAjoint_vignette/tips.html#visualization-tips # check to see the initial values that were used fit.w.inits$inits ## $chain1 ## $chain1$mu_trad ## [1] 2.01391381 1.25559601 0.41563428 4.82694638 0.83600351 4.30748495 2.36601809 ## [8] 0.39530283 1.45825815 2.66141690 3.32957309 3.60864127 2.34038247 4.92368838 ## [15] 2.11719136 0.91069842 2.67780586 3.86534942 4.80623740 2.17228961 4.20042273 ## [22] 3.34444017 2.28607129 0.15141236 0.68654561 3.06456579 4.73994272 3.70362987 ## [29] 3.99786725 2.04876099 2.93804214 0.91720229 0.58064812 3.33776691 2.98863764 ## [36] 2.55980605 0.06658861 4.39519622 4.67691937 ## ## $chain1$mu ## [1] 2.01391381 1.25559601 0.41563428 4.82694638 0.83600351 4.30748495 2.36601809 ## [8] 0.39530283 1.45825815 2.66141690 3.32957309 3.60864127 2.34038247 4.92368838 ## [15] 2.11719136 0.91069842 2.67780586 3.86534942 4.80623740 2.17228961 4.20042273 ## [22] 3.34444017 2.28607129 0.15141236 0.68654561 3.06456579 4.73994272 3.70362987 ## [29] 3.99786725 2.04876099 2.93804214 0.91720229 0.58064812 3.33776691 2.98863764 ## [36] 2.55980605 0.06658861 4.39519622 4.67691937 ## ## $chain1$log_p10 ## [1] -2.999918 ## ## $chain1$beta ## [1] 0.05397204 ## ## ## $chain2 ## $chain2$mu_trad ## [1] 0.9654809 2.2014818 0.9671374 3.1678988 4.5603247 1.8170409 4.5563945 3.9641428 ## [9] 4.8218774 3.0925700 1.9031798 1.6237121 1.3969457 3.9350216 1.8576002 4.2436057 ## [17] 3.2635289 2.5389627 1.2403107 3.2642428 0.6320112 4.7961765 2.1780876 4.3163066 ## [25] 3.9847331 4.2370985 0.1399096 1.2657270 1.8978087 2.0389883 4.1236273 3.9105557 ## [33] 4.9132148 3.5091323 2.6031631 4.3297012 3.6721368 3.3247593 0.4818758 ## ## $chain2$mu ## [1] 0.9654809 2.2014818 0.9671374 3.1678988 4.5603247 1.8170409 4.5563945 3.9641428 ## [9] 4.8218774 3.0925700 1.9031798 1.6237121 1.3969457 3.9350216 1.8576002 4.2436057 ## [17] 3.2635289 2.5389627 1.2403107 3.2642428 0.6320112 4.7961765 2.1780876 4.3163066 ## [25] 3.9847331 4.2370985 0.1399096 1.2657270 1.8978087 2.0389883 4.1236273 3.9105557 ## [33] 4.9132148 3.5091323 2.6031631 4.3297012 3.6721368 3.3247593 0.4818758 ## ## $chain2$log_p10 ## [1] -2.655146 ## ## $chain2$beta ## [1] 0.111839 ## ## ## $chain3 ## $chain3$mu_trad ## [1] 0.9165691 2.6670734 2.2691038 3.8368410 0.8432949 4.3849986 0.4118777 1.0452265 ## [9] 1.7920187 3.8483753 2.4016282 4.1951907 1.7224685 3.0833681 0.9852619 1.8655148 ## [17] 3.9343529 4.5467676 2.7610491 4.3980515 3.5321668 2.7537674 0.8118323 1.6419269 ## [25] 2.2440976 4.0824542 2.9571905 1.3469608 3.3006075 0.5168841 1.1707444 4.2831916 ## [33] 3.6723485 3.8128558 4.2430229 2.7496592 2.9975857 4.9951764 2.2973047 ## ## $chain3$mu ## [1] 0.9165691 2.6670734 2.2691038 3.8368410 0.8432949 4.3849986 0.4118777 1.0452265 ## [9] 1.7920187 3.8483753 2.4016282 4.1951907 1.7224685 3.0833681 0.9852619 1.8655148 ## [17] 3.9343529 4.5467676 2.7610491 4.3980515 3.5321668 2.7537674 0.8118323 1.6419269 ## [25] 2.2440976 4.0824542 2.9571905 1.3469608 3.3006075 0.5168841 1.1707444 4.2831916 ## [33] 3.6723485 3.8128558 4.2430229 2.7496592 2.9975857 4.9951764 2.2973047 ## ## $chain3$log_p10 ## [1] -2.824668 ## ## $chain3$beta ## [1] 0.05075341 ## ## ## $chain4 ## $chain4$mu_trad ## [1] 0.2139959 3.8336850 2.2284548 3.8006431 3.7800381 0.3500877 2.7647242 1.7389432 ## [9] 3.1052340 0.1519294 0.2122061 2.3662545 4.9653820 0.8232471 3.7508484 4.2358386 ## [17] 1.8070711 1.4005192 4.5797479 1.3575003 2.6236618 1.8111736 3.9053329 1.1063771 ## [25] 1.4386567 2.5149701 2.0564225 4.8987182 4.3265848 1.8907922 2.6205461 2.8983300 ## [33] 2.5966957 2.2764267 0.9491063 2.6725291 4.7969291 2.1751389 0.9637220 ## ## $chain4$mu ## [1] 0.2139959 3.8336850 2.2284548 3.8006431 3.7800381 0.3500877 2.7647242 1.7389432 ## [9] 3.1052340 0.1519294 0.2122061 2.3662545 4.9653820 0.8232471 3.7508484 4.2358386 ## [17] 1.8070711 1.4005192 4.5797479 1.3575003 2.6236618 1.8111736 3.9053329 1.1063771 ## [25] 1.4386567 2.5149701 2.0564225 4.8987182 4.3265848 1.8907922 2.6205461 2.8983300 ## [33] 2.5966957 2.2764267 0.9491063 2.6725291 4.7969291 2.1751389 0.9637220 ## ## $chain4$log_p10 ## [1] -2.869797 ## ## $chain4$beta ## [1] 0.07853136 "],["usecase2.html", "Chapter 4 Use case 2: jointModel() with site-level covariates 4.1 Fit the model 4.2 Model selection 4.3 Interpret the output 4.4 Initial values", " Chapter 4 Use case 2: jointModel() with site-level covariates This second use case uses the same goby data as in use case 1, except this time we will include site-level covariates that affect the sensitivity of eDNA relative to traditional surveys. library(eDNAjoint) data(gobyData) In addition to count and qPCR data, the goby data includes site-level covariates, which is optional when implementing jointModel(). Here, the data represent salinity, mean time to filter eDNA samples, density of other fish, habitat size, and vegetation presence at each site. Two important notes: Notice that the continuous covariate data is standardized. This is useful since this data will be used in a linear regression. Similarly, one should use dummy variables for categorical variables (like the ‘Veg’ variable). The columns in the matrix should be named, since these identifiers will be used when fitting the model. head(gobyData$site.cov) ## Salinity Filter_time Other_fishes Hab_size Veg ## [1,] -0.7114925 -1.17 0.0 -0.2715560 0 ## [2,] -0.2109183 -1.24 0.0 -0.2663009 0 ## [3,] -1.1602831 -1.29 0.0 -0.2717707 0 ## [4,] -0.5561419 0.11 160.9 -0.2164312 1 ## [5,] -0.9876713 -0.70 113.0 4.9981956 1 ## [6,] 1.2562818 -0.55 19.3 -0.2934710 0 For more data formatting guidance, see section 2.1.1. 4.1 Fit the model Now that we understand our data, let’s fit the joint model. The key arguments of this function include: data: list of qPCR.K, qPCR.N, count, and site.cov matrices cov: character vector of site-level covariates (this model will only include mean eDNA sample filter time and salinity) family: probability distribution used to model the seine count data. A poisson distribution is chosen here. p10priors: Beta distribution parameters for the prior on the probability of false positive eDNA detection, \\(p_{10}\\). c(1,20) is the default specification. More on this later. q: logical value indicating the presence of multiple traditional gear types. Here, we’re only using data from one traditional method. More parameters exist to further customize the MCMC sampling, but we’ll stick with the defaults. # run the joint model with two covariates goby.fit.cov1 &lt;- jointModel(data = gobyData, cov=c(&#39;Filter_time&#39;,&#39;Salinity&#39;), family = &#39;poisson&#39;, p10priors = c(1,20), q=FALSE) goby.fit.cov1 is a list containing: model fit (goby.fit.cov1$model) of the class ‘stanfit’ and can be accessed and interpreted using all functions in the rstan package. initial values used for each chain in MCMC (goby.fit.cov1$inits) 4.2 Model selection We previously made a choice to include two site-level covariates. Perhaps we want to test how that model specification compares to a model specification with different site-level covariates. # fit a new model with one site-level covariate goby.fit.cov2 &lt;- jointModel(data = gobyData, cov=&#39;Other_fishes&#39;, family = &#39;poisson&#39;, p10priors = c(1,20), q=FALSE) We can now compare the fit of these model to our data using the jointSelect() function, which performs leave-one-out cross validation with functions from the loo package. # perform model selection jointSelect(modelfits = list(goby.fit.cov1$model, goby.fit.cov2$model)) ## elpd_diff se_diff ## model1 0.0 0.0 ## model2 -27.9 23.8 These results tell us that model1 has a higher Bayesian LOO estimate of the expected log pointwise predictive density (elpd_loo). This means that goby.fit.cov1 is likely a better fit to the data. You could keep going with this further and include/exclude different covariates, or compare to a null model without covariates. 4.3 Interpret the output 4.3.1 Summarize posterior distributions Let’s interpret goby.fit.cov1. Use jointSummarize() to see the posterior summaries of the model parameters. jointSummarize(goby.fit.cov1$model, par = c(&#39;p10&#39;,&#39;alpha&#39;)) ## mean se_mean sd 2.5% 97.5% n_eff Rhat ## p10 0.003 0.000 0.001 0.001 0.007 17936.752 1 ## alpha[1] 0.542 0.001 0.099 0.350 0.734 10214.238 1 ## alpha[2] 1.021 0.001 0.118 0.788 1.249 9351.836 1 ## alpha[3] -0.349 0.001 0.107 -0.559 -0.133 11165.492 1 This summarizes the mean, sd, and quantiles of the posterior estimates of \\(p_{10}\\) and \\(\\alpha\\), as well as the effective sample size (n_eff) and Rhat for the parameters. The mean estimated probability of a false positive eDNA detection is 0.001. In use case 1, the scalar parameter \\(\\beta\\) was used to scale the relationship between eDNA and traditional sampling, but now the vector \\(\\alpha\\) represents the regression covariates that scales this relationship (see model description for more). alpha[1] corresponds to the intercept of the regression with site-level covariates. alpha[2] corresponds to the regression coefficient associated with Filter_time, and alpha[3] corresponds to the regression coefficient associated with Salinity. Positive regression coefficients indicate an inverse relationship between the covariate and eDNA sensitivity. We can also use functions from the bayesplot package to examine the posterior distributions and chain convergence. First let’s look at the posterior distribution for \\(p_{10}\\). library(bayesplot) # plot posterior distribution, highlighting median and 80% credibility interval mcmc_areas(as.matrix(goby.fit.cov1$model), pars = &#39;p10&#39;, prob = 0.8) Next let’s look at chain convergence for \\(p_{10}\\) and \\(\\mu_{i=1}\\). # this will plot the MCMC chains for p10 and mu at site 1 mcmc_trace(rstan::extract(goby.fit.cov1$model, permuted = FALSE), pars = c(&#39;p10&#39;, &#39;mu[1]&#39;)) 4.3.2 Effort necessary to detect presence To further highlight the relative sensitivity of eDNA and traditional sampling, we can use detectionCalculate() to find the units of survey effort necessary to detect presence of the species. Here, detecting presence refers to producing at least one true positive eDNA detection or catching at least one individual in a traditional survey. This function is finding the median number of survey units necessary to detect species presence if the expected catch rate, \\(\\mu\\) is 0.1, 0.5, or 1. The cov.val argument indicates the value of the covariates used for the prediction. Since the covariate data was standardized, c(0,0) indicates that the prediction is made at the mean Filter_time and Salinity values. detectionCalculate(goby.fit.cov1$model, mu=c(0.1,0.5,1), cov.val = c(0,0), probability = 0.9) ## mu n_traditional n_eDNA ## [1,] 0.1 24 14 ## [2,] 0.5 5 4 ## [3,] 1.0 3 2 We can see that at the mean covariate values, it takes 14 eDNA samples or 24 seine samples to detect goby presence with 0.9 probability if the expected catch rate is 0.1. Now let’s perform the same calculation under a condition where the Filter_time covariate value is 0.5 z-scores above the mean. detectionCalculate(goby.fit.cov1$model, mu=c(0.1,0.5,1), cov.val = c(0.5,0), probability = 0.9) ## mu n_traditional n_eDNA ## [1,] 0.1 24 23 ## [2,] 0.5 5 5 ## [3,] 1.0 3 3 At sites with a longer eDNA sample filter time, it would now take 22 eDNA samples or 24 seine samples to detect goby presence if the expected catch rate is 0.1. Let’s do the same for salinity. detectionCalculate(goby.fit.cov1$model, mu=c(0.1,0.5,1), cov.val = c(0,0.5), probability = 0.9) ## mu n_traditional n_eDNA ## [1,] 0.1 24 12 ## [2,] 0.5 5 3 ## [3,] 1.0 3 2 At sites with higher salinity, it would now take 12 eDNA samples or 24 seine samples to detect goby presence if the expected catch rate is 0.1. We can also plot these comparisons. mu.min and mu.max define the x-axis in the plot. detectionPlot(goby.fit.cov1$model, mu.min=0.1, mu.max =1, cov.val = c(0,0), probability = 0.9) 4.3.3 Calculate \\(\\mu_{critical}\\) The probability of a true positive eDNA detection, \\(p_{11}\\), is a function of the expected catch rate, \\(\\mu\\). Low values of \\(\\mu\\) correspond to low probability of eDNA detection. Since the probability of a false-positive eDNA detection is non-zero, the probability of a false positive detection may be higher than the probability of a true positive detection at very low values of \\(\\mu\\). \\(\\mu_{critical}\\) describes the value of \\(\\mu\\) where the probability of a false positive eDNA detection equals the probability of a true positive eDNA detection. This value can be calculated using muCritical(). Here, we will calculate this value at the mean covariate values. muCritical(goby.fit.cov1$model, cov.val = c(0,0), ci = 0.9) ## $median ## [1] 0.005294315 ## ## $lower_ci ## Highest Density Interval: 1.69e-03 ## ## $upper_ci ## Highest Density Interval: 9.60e-03 This function calculates \\(\\mu_{critical}\\) using the entire posterior distributions of parameters from the model, and ‘HDI’ corresponds to the 90% credibility interval calculated using the highest density interval. 4.4 Initial values By default, eDNAjoint will provide initial values for parameters estimated by the model, but you can provide your own initial values if you prefer. Here is an example of providing initial values for parameters, mu,p10, and alpha, as an input in jointModel(). # set number of chains n.chain &lt;- 4 # initial values should be a list of named lists inits &lt;- list() for(i in 1:n.chain){ inits[[i]] &lt;- list( # length should equal the number of sites (dim(gobyData$count)[1]) for each chain mu = stats::runif(dim(gobyData$count)[1], 0.01, 5), # length should equal 1 for each chain p10 = stats::runif(1,0.0001,0.08), # length should equal the number of covariates plus 1 (to account for intercept in regression) alpha = rep(0.1,length(c(&#39;Filter_time&#39;,&#39;Salinity&#39;))+1) ) } # now fit the model fit.w.inits &lt;- jointModel(data = gobyData, cov=c(&#39;Filter_time&#39;,&#39;Salinity&#39;), initial_values = inits) ## ## SAMPLING FOR MODEL &#39;joint_binary_cov_pois&#39; NOW (CHAIN 1). ## Chain 1: ## Chain 1: Gradient evaluation took 0.0001 seconds ## Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 1 seconds. ## Chain 1: Adjust your expectations accordingly! ## Chain 1: ## Chain 1: ## Chain 1: Iteration: 1 / 3000 [ 0%] (Warmup) ## Chain 1: Iteration: 500 / 3000 [ 16%] (Warmup) ## Chain 1: Iteration: 501 / 3000 [ 16%] (Sampling) ## Chain 1: Iteration: 1000 / 3000 [ 33%] (Sampling) ## Chain 1: Iteration: 1500 / 3000 [ 50%] (Sampling) ## Chain 1: Iteration: 2000 / 3000 [ 66%] (Sampling) ## Chain 1: Iteration: 2500 / 3000 [ 83%] (Sampling) ## Chain 1: Iteration: 3000 / 3000 [100%] (Sampling) ## Chain 1: ## Chain 1: Elapsed Time: 2.402 seconds (Warm-up) ## Chain 1: 4.639 seconds (Sampling) ## Chain 1: 7.041 seconds (Total) ## Chain 1: ## ## SAMPLING FOR MODEL &#39;joint_binary_cov_pois&#39; NOW (CHAIN 2). ## Chain 2: ## Chain 2: Gradient evaluation took 9.2e-05 seconds ## Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.92 seconds. ## Chain 2: Adjust your expectations accordingly! ## Chain 2: ## Chain 2: ## Chain 2: Iteration: 1 / 3000 [ 0%] (Warmup) ## Chain 2: Iteration: 500 / 3000 [ 16%] (Warmup) ## Chain 2: Iteration: 501 / 3000 [ 16%] (Sampling) ## Chain 2: Iteration: 1000 / 3000 [ 33%] (Sampling) ## Chain 2: Iteration: 1500 / 3000 [ 50%] (Sampling) ## Chain 2: Iteration: 2000 / 3000 [ 66%] (Sampling) ## Chain 2: Iteration: 2500 / 3000 [ 83%] (Sampling) ## Chain 2: Iteration: 3000 / 3000 [100%] (Sampling) ## Chain 2: ## Chain 2: Elapsed Time: 2.029 seconds (Warm-up) ## Chain 2: 4.233 seconds (Sampling) ## Chain 2: 6.262 seconds (Total) ## Chain 2: ## ## SAMPLING FOR MODEL &#39;joint_binary_cov_pois&#39; NOW (CHAIN 3). ## Chain 3: ## Chain 3: Gradient evaluation took 9.4e-05 seconds ## Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.94 seconds. ## Chain 3: Adjust your expectations accordingly! ## Chain 3: ## Chain 3: ## Chain 3: Iteration: 1 / 3000 [ 0%] (Warmup) ## Chain 3: Iteration: 500 / 3000 [ 16%] (Warmup) ## Chain 3: Iteration: 501 / 3000 [ 16%] (Sampling) ## Chain 3: Iteration: 1000 / 3000 [ 33%] (Sampling) ## Chain 3: Iteration: 1500 / 3000 [ 50%] (Sampling) ## Chain 3: Iteration: 2000 / 3000 [ 66%] (Sampling) ## Chain 3: Iteration: 2500 / 3000 [ 83%] (Sampling) ## Chain 3: Iteration: 3000 / 3000 [100%] (Sampling) ## Chain 3: ## Chain 3: Elapsed Time: 2.384 seconds (Warm-up) ## Chain 3: 4.396 seconds (Sampling) ## Chain 3: 6.78 seconds (Total) ## Chain 3: ## ## SAMPLING FOR MODEL &#39;joint_binary_cov_pois&#39; NOW (CHAIN 4). ## Chain 4: ## Chain 4: Gradient evaluation took 0.000205 seconds ## Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 2.05 seconds. ## Chain 4: Adjust your expectations accordingly! ## Chain 4: ## Chain 4: ## Chain 4: Iteration: 1 / 3000 [ 0%] (Warmup) ## Chain 4: Iteration: 500 / 3000 [ 16%] (Warmup) ## Chain 4: Iteration: 501 / 3000 [ 16%] (Sampling) ## Chain 4: Iteration: 1000 / 3000 [ 33%] (Sampling) ## Chain 4: Iteration: 1500 / 3000 [ 50%] (Sampling) ## Chain 4: Iteration: 2000 / 3000 [ 66%] (Sampling) ## Chain 4: Iteration: 2500 / 3000 [ 83%] (Sampling) ## Chain 4: Iteration: 3000 / 3000 [100%] (Sampling) ## Chain 4: ## Chain 4: Elapsed Time: 1.837 seconds (Warm-up) ## Chain 4: 4.529 seconds (Sampling) ## Chain 4: 6.366 seconds (Total) ## Chain 4: ## Refer to the eDNAjoint guide for visualization tips: https://bookdown.org/abigailkeller/eDNAjoint_vignette/tips.html#visualization-tips # check to see the initial values that were used fit.w.inits$inits ## $chain1 ## $chain1$mu_trad ## [1] 2.04393687 2.13858200 0.83867409 1.82922529 4.21995384 1.38082632 4.28211934 ## [8] 3.53658081 4.16123419 3.76859712 1.33127074 4.55114092 2.33118368 0.81521753 ## [15] 4.47183180 2.04776085 2.64797997 0.66674815 1.39890668 1.00416212 0.68292900 ## [22] 3.09098650 0.59747924 2.53917391 1.64250020 4.37446245 0.11000119 0.08903043 ## [29] 0.49631369 1.36427525 1.63104675 2.30288276 4.69588402 0.60685573 3.98933093 ## [36] 4.26983533 4.46034743 0.47263531 0.89076780 ## ## $chain1$mu ## [1] 2.04393687 2.13858200 0.83867409 1.82922529 4.21995384 1.38082632 4.28211934 ## [8] 3.53658081 4.16123419 3.76859712 1.33127074 4.55114092 2.33118368 0.81521753 ## [15] 4.47183180 2.04776085 2.64797997 0.66674815 1.39890668 1.00416212 0.68292900 ## [22] 3.09098650 0.59747924 2.53917391 1.64250020 4.37446245 0.11000119 0.08903043 ## [29] 0.49631369 1.36427525 1.63104675 2.30288276 4.69588402 0.60685573 3.98933093 ## [36] 4.26983533 4.46034743 0.47263531 0.89076780 ## ## $chain1$log_p10 ## [1] -3.772597 ## ## $chain1$alpha ## [1] 0.1 0.1 0.1 ## ## ## $chain2 ## $chain2$mu_trad ## [1] 3.01635005 2.06144046 4.83685517 1.67723976 2.74920443 0.07283268 0.94866626 ## [8] 4.02085528 3.78160175 2.44499350 0.93607497 2.77077091 2.78276236 4.13368673 ## [15] 0.78000261 0.88399910 3.33101891 4.96586164 3.27106349 0.40887031 1.86665386 ## [22] 2.04405172 3.07021541 0.62712856 4.18949439 4.20857730 1.62403515 1.51708704 ## [29] 3.71060991 1.33882569 0.59757919 0.30688147 0.02004547 1.31292310 0.11612407 ## [36] 1.79071353 2.38124515 0.26818945 3.27737829 ## ## $chain2$mu ## [1] 3.01635005 2.06144046 4.83685517 1.67723976 2.74920443 0.07283268 0.94866626 ## [8] 4.02085528 3.78160175 2.44499350 0.93607497 2.77077091 2.78276236 4.13368673 ## [15] 0.78000261 0.88399910 3.33101891 4.96586164 3.27106349 0.40887031 1.86665386 ## [22] 2.04405172 3.07021541 0.62712856 4.18949439 4.20857730 1.62403515 1.51708704 ## [29] 3.71060991 1.33882569 0.59757919 0.30688147 0.02004547 1.31292310 0.11612407 ## [36] 1.79071353 2.38124515 0.26818945 3.27737829 ## ## $chain2$log_p10 ## [1] -3.080158 ## ## $chain2$alpha ## [1] 0.1 0.1 0.1 ## ## ## $chain3 ## $chain3$mu_trad ## [1] 0.8794226 1.0186518 3.7261763 3.1065839 1.7779727 4.7689924 0.5885190 4.8133300 ## [9] 4.6733623 1.5499288 0.7457254 3.1389496 0.7198004 1.1160017 3.1807162 2.1938935 ## [17] 4.6646939 1.5674118 3.7160366 2.0399502 3.4711256 1.8639314 4.9833057 4.0642200 ## [25] 0.7002595 0.2942121 3.8189961 0.7851154 2.5977143 3.9956082 3.7263295 1.1804083 ## [33] 1.9211221 3.9175265 4.6037509 3.9741671 2.4296695 0.3311350 0.3262873 ## ## $chain3$mu ## [1] 0.8794226 1.0186518 3.7261763 3.1065839 1.7779727 4.7689924 0.5885190 4.8133300 ## [9] 4.6733623 1.5499288 0.7457254 3.1389496 0.7198004 1.1160017 3.1807162 2.1938935 ## [17] 4.6646939 1.5674118 3.7160366 2.0399502 3.4711256 1.8639314 4.9833057 4.0642200 ## [25] 0.7002595 0.2942121 3.8189961 0.7851154 2.5977143 3.9956082 3.7263295 1.1804083 ## [33] 1.9211221 3.9175265 4.6037509 3.9741671 2.4296695 0.3311350 0.3262873 ## ## $chain3$log_p10 ## [1] -2.8294 ## ## $chain3$alpha ## [1] 0.1 0.1 0.1 ## ## ## $chain4 ## $chain4$mu_trad ## [1] 4.4877811 2.1727203 4.8477993 4.9769401 2.1355919 2.4980598 1.1584333 2.0122739 ## [9] 4.6931959 1.6861870 1.4401861 2.4905163 1.2097323 2.1351682 0.9459020 2.8799340 ## [17] 2.7651233 3.4719783 4.5412596 3.0174997 2.6866175 4.1852320 3.0637430 2.9050648 ## [25] 2.7907714 4.7318266 0.5644405 1.6773707 0.3710265 1.7159281 0.2033197 2.6271268 ## [33] 4.0964929 0.1488295 4.8786893 0.3042488 3.2843939 2.6484452 1.3460973 ## ## $chain4$mu ## [1] 4.4877811 2.1727203 4.8477993 4.9769401 2.1355919 2.4980598 1.1584333 2.0122739 ## [9] 4.6931959 1.6861870 1.4401861 2.4905163 1.2097323 2.1351682 0.9459020 2.8799340 ## [17] 2.7651233 3.4719783 4.5412596 3.0174997 2.6866175 4.1852320 3.0637430 2.9050648 ## [25] 2.7907714 4.7318266 0.5644405 1.6773707 0.3710265 1.7159281 0.2033197 2.6271268 ## [33] 4.0964929 0.1488295 4.8786893 0.3042488 3.2843939 2.6484452 1.3460973 ## ## $chain4$log_p10 ## [1] -3.553015 ## ## $chain4$alpha ## [1] 0.1 0.1 0.1 "],["usecase3.html", "Chapter 5 Use case 3: jointModel() with multiple traditional gear types 5.1 Prepare the data 5.2 Fit the model 5.3 Model selection 5.4 Interpret the output 5.5 traditionalModel() 5.6 Initial values", " Chapter 5 Use case 3: jointModel() with multiple traditional gear types This third use case will show how to fit and interpret the joint model with paired eDNA and traditional survey data when multiple traditional gear types have been used. These different gear types may have different expected catch rates, \\(\\mu\\), represented by gear-specific scaling coefficients q. The data used in this example comes from a study by Keller et al. (2022) about invasive European green crab (Carcinus maenas) in Washington state. Environmental DNA samples were collected at 20 sites, along with paired baited trap sampling. The eDNA data is detection/non-detection data generated through quantitative polymerase chain reaction (qPCR). 5.1 Prepare the data Similar to the goby data, the green crab data is still a list of matrices. Now, instead of data on site-level covariates, site.cov, there is data representing the gear type for each of the traditional samples, count.type. library(eDNAjoint) data(greencrabData) names(greencrabData) ## [1] &quot;qPCR.N&quot; &quot;qPCR.K&quot; &quot;count&quot; &quot;count.type&quot; Again, all matrices should have the same number of rows (n=20), and rows across all four matrices should correspond to the same sites. Let’s look at the count. This data is from baited trap sampling for green crab. Each integer refers to the catch of each trap (i.e., catch per unit effort, when effort = 1). The rows correspond to sites, and the columns refer to the replicated trap samples (secondary sample units) at each site, with a maximum of 420 samples. dim(greencrabData$count) ## [1] 20 420 Blank spaces are filled with NA at sites where fewer trap samples were collected than the maximum. In this example, the count data are integers, but continuous values can be used in the model (see Eq. 1.3 in the model description). greencrabData$count[1:6,1:20] ## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ## [1,] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [2,] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [3,] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [4,] 1 0 1 2 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 1 ## [5,] 0 0 0 0 0 0 0 0 NA NA NA NA NA NA NA NA NA NA NA NA ## [6,] 0 0 0 0 0 0 NA NA NA NA NA NA NA NA NA NA NA NA NA NA Next, let’s look at count.type, which consists of integer indicators of gear type for each trap sample. Here, 1 refers to the Fukui gear type, and 2 refers to the Minnow gear type. greencrabData$count.type[1:6,1:20] ## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ## [1,] 1 1 1 1 2 1 2 2 2 2 2 2 1 1 1 1 2 1 1 2 ## [2,] 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 2 2 2 2 ## [3,] 1 1 1 2 1 2 1 1 1 2 1 2 2 1 2 2 1 2 1 2 ## [4,] 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2 2 ## [5,] 1 2 1 2 1 2 1 2 NA NA NA NA NA NA NA NA NA NA NA NA ## [6,] 2 1 2 1 2 1 NA NA NA NA NA NA NA NA NA NA NA NA NA NA Note that the locations of the NAs in this matrix match count. For more data formatting guidance, see section 2.1.1. 5.2 Fit the model Now that we understand our data, let’s fit the joint model. The key arguments of this function include: data: list of qPCR.K, qPCR.N, count, and count.type matrices cov: no site-level covariates are included in this model family: probability distribution used to model the trap count data. A negative binomial distribution is chosen here. p10priors: Beta distribution parameters for the prior on the probability of false positive eDNA detection, \\(p_{10}\\). c(1,20) is the default specification. q: logical value indicating the presence of multiple traditional gear types. More parameters exist to further customize the MCMC sampling, but we’ll stick with the defaults. # run the joint model with gear scaling coefficients greencrab.fit.q.negbin &lt;- jointModel(data = greencrabData, cov = NULL, family = &#39;negbin&#39;, p10priors = c(1,20), q = TRUE) 5.3 Model selection We previously made a choice to model the green crab count data with a negative binomial distribution. Perhaps we want to test how that model specification compares to a model specification where count data is modeled with a poisson distribution. # run the joint model with poisson distribution greencrab.fit.q.pois &lt;- jointModel(data = greencrabData, cov=NULL, family = &#39;poisson&#39;, p10priors = c(1,20), q=TRUE) Let’s also fit some models where we assume that both gear types have the same catchability. We set q=FALSE to not estimate gear scaling coefficients. # run the joint model with four covariates greencrab.fit.negbin &lt;- jointModel(data = greencrabData, cov=NULL, family = &#39;negbin&#39;, p10priors = c(1,20), q=FALSE) greencrab.fit.pois &lt;- jointModel(data = greencrabData, cov=NULL, family = &#39;poisson&#39;, p10priors = c(1,20), q=FALSE) Now let’s perform model selection using leave-one-out cross validation. # perform model selection jointSelect(modelfits = list( # include gear scaling coefficient, model count data with negative binomial greencrab.fit.q.negbin$model, # include gear scaling coefficient, model count data with poisson greencrab.fit.q.pois$model, # include gear scaling coefficient, model count data with negative binomial greencrab.fit.negbin$model, # include gear scaling coefficient, model count data with poisson greencrab.fit.pois$model)) ## elpd_diff se_diff ## model3 0.0 0.0 ## model1 -1.0 1.9 ## model4 -165.9 38.4 ## model2 -168.5 37.7 These results tell us that models one and three (models with and without gear scaling coefficients for the gear types) that use a negative binomial distribution for count data have similar Bayesian LOO estimates of the expected log pointwise predictive density (elpd_loo). Notably, a negative binomial distribution represents the data-generating process for our count data much better than a poisson distribution. 5.4 Interpret the output 5.4.1 Summarize posterior distributions For the sake of illustration, let’s interpret the results of the model fit with gear scaling coefficients. Use jointSummarize() to see the posterior summaries of the model parameters. jointSummarize(greencrab.fit.q.negbin$model, par = c(&#39;p10&#39;,&#39;beta&#39;,&#39;q&#39;)) ## mean se_mean sd 2.5% 97.5% n_eff Rhat ## p10 0.019 0.000 0.010 0.005 0.041 10842.124 1 ## beta 1.265 0.003 0.245 0.800 1.767 8633.901 1 ## q[1] 0.795 0.001 0.101 0.611 1.006 6699.013 1 This summarizes the mean, sd, and quantiles of the posterior estimates of \\(p_{10}\\), \\(\\beta\\), and q, as well as the effective sample size (n_eff) and Rhat for the parameters. The mean estimated probability of a false positive eDNA detection is ~0.01. beta is the parameter that scales the sensitivity of eDNA sampling relative to trap sampling. q[1] represents the gear scaling coefficient of gear type 2, which scales the catch rate of gear type 2 relative to gear type 1. Now let’s look at the summary of mu. jointSummarize(greencrab.fit.q.negbin$model, par = &#39;mu&#39;) ## mean se_mean sd 2.5% 97.5% n_eff Rhat ## mu[1,1] 0.107 0.000 0.028 0.060 0.169 12092.729 1 ## mu[1,2] 0.084 0.000 0.023 0.047 0.136 13041.050 1 ## mu[2,1] 0.032 0.000 0.034 0.001 0.124 13058.609 1 ## mu[2,2] 0.026 0.000 0.027 0.001 0.098 13179.902 1 ## mu[3,1] 0.017 0.000 0.017 0.000 0.063 12227.341 1 ## mu[3,2] 0.014 0.000 0.014 0.000 0.051 12585.700 1 ## mu[4,1] 0.678 0.001 0.105 0.497 0.912 10471.339 1 ## mu[4,2] 0.535 0.001 0.090 0.380 0.730 12571.650 1 ## mu[5,1] 0.100 0.001 0.107 0.002 0.389 13321.944 1 ## mu[5,2] 0.079 0.001 0.085 0.002 0.311 13236.365 1 ## mu[6,1] 0.120 0.001 0.131 0.003 0.489 12253.316 1 ## mu[6,2] 0.094 0.001 0.103 0.003 0.381 12425.582 1 ## mu[7,1] 0.013 0.000 0.013 0.000 0.046 12839.668 1 ## mu[7,2] 0.010 0.000 0.010 0.000 0.037 12726.795 1 ## mu[8,1] 0.304 0.003 0.286 0.013 1.079 12499.904 1 ## mu[8,2] 0.240 0.002 0.227 0.010 0.840 12691.972 1 ## mu[9,1] 0.033 0.000 0.032 0.001 0.120 12449.077 1 ## mu[9,2] 0.026 0.000 0.026 0.001 0.095 12803.333 1 ## mu[10,1] 1.045 0.002 0.245 0.644 1.599 10223.025 1 ## mu[10,2] 0.824 0.002 0.191 0.503 1.250 12519.448 1 ## mu[11,1] 0.302 0.003 0.286 0.013 1.072 12011.363 1 ## mu[11,2] 0.238 0.002 0.227 0.010 0.837 12166.721 1 ## mu[12,1] 0.021 0.000 0.022 0.000 0.081 12903.994 1 ## mu[12,2] 0.017 0.000 0.017 0.000 0.063 12735.318 1 ## mu[13,1] 7.668 0.014 1.318 5.509 10.646 8913.679 1 ## mu[13,2] 6.034 0.008 0.974 4.411 8.168 13198.043 1 ## mu[14,1] 0.119 0.000 0.020 0.084 0.161 10068.020 1 ## mu[14,2] 0.094 0.000 0.016 0.065 0.128 12414.486 1 ## mu[15,1] 0.766 0.005 0.541 0.124 2.174 12110.728 1 ## mu[15,2] 0.604 0.004 0.426 0.099 1.726 12547.477 1 ## mu[16,1] 3.796 0.007 0.659 2.672 5.261 8987.115 1 ## mu[16,2] 2.984 0.004 0.469 2.171 4.008 14528.663 1 ## mu[17,1] 0.163 0.002 0.181 0.004 0.639 13027.682 1 ## mu[17,2] 0.129 0.001 0.143 0.003 0.503 13105.373 1 ## mu[18,1] 3.315 0.011 1.099 1.751 5.926 9633.229 1 ## mu[18,2] 2.615 0.008 0.872 1.371 4.770 10895.124 1 ## mu[19,1] 3.927 0.008 0.712 2.761 5.546 8701.826 1 ## mu[19,2] 3.097 0.005 0.567 2.169 4.381 11502.035 1 ## mu[20,1] 0.119 0.001 0.069 0.026 0.292 12473.216 1 ## mu[20,2] 0.094 0.000 0.055 0.020 0.226 12503.220 1 mu[1,1] corresponds to the expected catch rate at site 1 with gear type 1. mu[1,2] corresponds to the expected catch rate at site 1 with gear type 2. mu[2,1] corresponds to the expected catch rate at site 2 with gear type 1. We can also use functions from the bayesplot package to examine the posterior distributions and chain convergence. First let’s look at the posterior distribution for \\(p_{10}\\). library(bayesplot) # plot posterior distribution, highlighting median and 80% credibility interval mcmc_areas(as.matrix(greencrab.fit.q.negbin$model), pars = &#39;p10&#39;, prob = 0.8) Next let’s look at chain convergence for \\(p_{10}\\) and \\(\\beta\\). # this will plot the MCMC chains for p10 and mu at site 1 mcmc_trace(rstan::extract(greencrab.fit.q.negbin$model, permuted = FALSE), pars = c(&#39;p10&#39;, &#39;beta&#39;)) 5.4.2 Effort necessary to detect presence To further highlight these results, we can use detectionCalculate() to find the units of survey effort necessary to detect presence of the species. This function is finding the median number of survey units necessary to detect species presence if the expected catch rate, \\(\\mu\\) is 0.1, 0.5, or 1. \\(\\mu\\) now represents the expected catch rate of gear type 1. detectionCalculate(greencrab.fit.q.negbin$model, mu = c(0.1,0.5,1), probability = 0.9) ## mu n_traditional_1 n_traditional_2 n_eDNA ## [1,] 0.1 25 31 28 ## [2,] 0.5 6 8 6 ## [3,] 1.0 4 5 4 We can see that it takes 27 eDNA samples, 25 trap samples (gear type 1), and 31 trap samples (gear type 2) to detect green crab presence with 0.9 probability if the expected catch rate with gear type 1 is 0.1. We can also plot these comparisons. mu.min and mu.max define the x-axis in the plot and represent the expected catch rate of gear type 1. detectionPlot(greencrab.fit.q.negbin$model, mu.min = 0.1, mu.max = 1, probability = 0.9) 5.4.3 Calculate \\(\\mu_{critical}\\) Now let’s calculate \\(\\mu_{critical}\\), which is the value of \\(\\mu\\) where the probability of a false positive eDNA detection equals the probability of a true positive eDNA detection. muCritical(greencrab.fit.q.negbin$model, cov.val = NULL, ci = 0.9) ## gear_1 gear_2 ## median 0.06008454 0.047477497 ## lower_ci 0.01024929 0.007951609 ## upper_ci 0.13458086 0.105297563 This function calculates \\(\\mu_{critical}\\) using the entire posterior distributions of parameters from the model, and ‘HDI’ corresponds to the 90% credibility interval calculated using the highest density interval. The first column corresponds to \\(\\mu_{critical}\\) if gear type 1 is used, and the second columns corresponds to \\(\\mu_{critical}\\) if gear type 2 is used. 5.5 traditionalModel() In some circumstances, it may be helpful to model just the traditional survey data without eDNA data for comparison. Use traditionalModel here, which requires the following parameters: data: list of count and (optionally) count.type matrices family: probability distribution used to model the trap count data. A negative binomial distribution is chosen here. q: logical value indicating the presence of multiple traditional gear types. More parameters exist to further customize the MCMC sampling, but we’ll stick with the defaults. # run the traditional model model with gear scaling coefficients greencrab.traditional &lt;- traditionalModel(data = greencrabData, family = &#39;negbin&#39;, q = TRUE) 5.6 Initial values By default, eDNAjoint will provide initial values for parameters estimated by the model, but you can provide your own initial values if you prefer. Here is an example of providing initial values for parameters, mu,p10, beta, and q, as an input in jointModel(). # set number of chains n.chain &lt;- 4 # initial values should be a list of named lists inits &lt;- list() for(i in 1:n.chain){ inits[[i]] &lt;- list( # length should equal the number of sites (dim(greencrabData$count)[1]) for each chain mu = stats::runif(dim(greencrabData$count)[1], 0.01, 5), # length should equal 1 for each chain p10 = stats::runif(1,0.0001,0.08), # length should equal 1 for each chain beta = stats::runif(1,0.05,0.2), # length should equal the number of gear types - 1 q = stats::runif( sum(!is.na(unique(as.vector(greencrabData$count.type))))-1, 0.5, 1.5 ) ) } # now fit the model fit.w.inits &lt;- jointModel(data = greencrabData, q = TRUE, initial_values = inits) ## ## SAMPLING FOR MODEL &#39;joint_binary_catchability_pois&#39; NOW (CHAIN 1). ## Chain 1: ## Chain 1: Gradient evaluation took 0.004588 seconds ## Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 45.88 seconds. ## Chain 1: Adjust your expectations accordingly! ## Chain 1: ## Chain 1: ## Chain 1: Iteration: 1 / 3000 [ 0%] (Warmup) ## Chain 1: Iteration: 500 / 3000 [ 16%] (Warmup) ## Chain 1: Iteration: 501 / 3000 [ 16%] (Sampling) ## Chain 1: Iteration: 1000 / 3000 [ 33%] (Sampling) ## Chain 1: Iteration: 1500 / 3000 [ 50%] (Sampling) ## Chain 1: Iteration: 2000 / 3000 [ 66%] (Sampling) ## Chain 1: Iteration: 2500 / 3000 [ 83%] (Sampling) ## Chain 1: Iteration: 3000 / 3000 [100%] (Sampling) ## Chain 1: ## Chain 1: Elapsed Time: 4.498 seconds (Warm-up) ## Chain 1: 10.422 seconds (Sampling) ## Chain 1: 14.92 seconds (Total) ## Chain 1: ## ## SAMPLING FOR MODEL &#39;joint_binary_catchability_pois&#39; NOW (CHAIN 2). ## Chain 2: ## Chain 2: Gradient evaluation took 0.00054 seconds ## Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 5.4 seconds. ## Chain 2: Adjust your expectations accordingly! ## Chain 2: ## Chain 2: ## Chain 2: Iteration: 1 / 3000 [ 0%] (Warmup) ## Chain 2: Iteration: 500 / 3000 [ 16%] (Warmup) ## Chain 2: Iteration: 501 / 3000 [ 16%] (Sampling) ## Chain 2: Iteration: 1000 / 3000 [ 33%] (Sampling) ## Chain 2: Iteration: 1500 / 3000 [ 50%] (Sampling) ## Chain 2: Iteration: 2000 / 3000 [ 66%] (Sampling) ## Chain 2: Iteration: 2500 / 3000 [ 83%] (Sampling) ## Chain 2: Iteration: 3000 / 3000 [100%] (Sampling) ## Chain 2: ## Chain 2: Elapsed Time: 4.611 seconds (Warm-up) ## Chain 2: 11.633 seconds (Sampling) ## Chain 2: 16.244 seconds (Total) ## Chain 2: ## ## SAMPLING FOR MODEL &#39;joint_binary_catchability_pois&#39; NOW (CHAIN 3). ## Chain 3: ## Chain 3: Gradient evaluation took 0.000255 seconds ## Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 2.55 seconds. ## Chain 3: Adjust your expectations accordingly! ## Chain 3: ## Chain 3: ## Chain 3: Iteration: 1 / 3000 [ 0%] (Warmup) ## Chain 3: Iteration: 500 / 3000 [ 16%] (Warmup) ## Chain 3: Iteration: 501 / 3000 [ 16%] (Sampling) ## Chain 3: Iteration: 1000 / 3000 [ 33%] (Sampling) ## Chain 3: Iteration: 1500 / 3000 [ 50%] (Sampling) ## Chain 3: Iteration: 2000 / 3000 [ 66%] (Sampling) ## Chain 3: Iteration: 2500 / 3000 [ 83%] (Sampling) ## Chain 3: Iteration: 3000 / 3000 [100%] (Sampling) ## Chain 3: ## Chain 3: Elapsed Time: 4.064 seconds (Warm-up) ## Chain 3: 7.981 seconds (Sampling) ## Chain 3: 12.045 seconds (Total) ## Chain 3: ## ## SAMPLING FOR MODEL &#39;joint_binary_catchability_pois&#39; NOW (CHAIN 4). ## Chain 4: ## Chain 4: Gradient evaluation took 0.00016 seconds ## Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 1.6 seconds. ## Chain 4: Adjust your expectations accordingly! ## Chain 4: ## Chain 4: ## Chain 4: Iteration: 1 / 3000 [ 0%] (Warmup) ## Chain 4: Iteration: 500 / 3000 [ 16%] (Warmup) ## Chain 4: Iteration: 501 / 3000 [ 16%] (Sampling) ## Chain 4: Iteration: 1000 / 3000 [ 33%] (Sampling) ## Chain 4: Iteration: 1500 / 3000 [ 50%] (Sampling) ## Chain 4: Iteration: 2000 / 3000 [ 66%] (Sampling) ## Chain 4: Iteration: 2500 / 3000 [ 83%] (Sampling) ## Chain 4: Iteration: 3000 / 3000 [100%] (Sampling) ## Chain 4: ## Chain 4: Elapsed Time: 5.36 seconds (Warm-up) ## Chain 4: 7.099 seconds (Sampling) ## Chain 4: 12.459 seconds (Total) ## Chain 4: ## Refer to the eDNAjoint guide for visualization tips: https://bookdown.org/abigailkeller/eDNAjoint_vignette/tips.html#visualization-tips # check to see the initial values that were used fit.w.inits$inits ## $chain1 ## $chain1$mu_trad_1 ## [1] 4.0780805 1.6461503 1.8409625 3.8067218 4.8467818 4.9285195 4.9491822 2.6502479 ## [9] 1.7250343 4.7976077 3.8983880 0.6046407 1.7905315 3.2753873 3.6891999 0.9293645 ## [17] 1.8348874 3.5736912 2.1752346 4.3831472 ## ## $chain1$mu ## [1] 4.0780805 1.6461503 1.8409625 3.8067218 4.8467818 4.9285195 4.9491822 2.6502479 ## [9] 1.7250343 4.7976077 3.8983880 0.6046407 1.7905315 3.2753873 3.6891999 0.9293645 ## [17] 1.8348874 3.5736912 2.1752346 4.3831472 ## ## $chain1$log_p10 ## [1] -3.650117 ## ## $chain1$beta ## [1] 0.08127231 ## ## $chain1$q_trans ## initial_values[[i]]$q ## 1 0.601305 ## ## ## $chain2 ## $chain2$mu_trad_1 ## [1] 1.4338101 2.5878397 2.8904753 2.7515258 0.9257917 3.3239880 0.4693585 4.9146158 ## [9] 0.2296816 3.2920709 4.7342723 4.4256445 0.5334799 1.5910902 4.5501773 3.0226411 ## [17] 0.2046510 3.9737262 1.3052055 2.0850422 ## ## $chain2$mu ## [1] 1.4338101 2.5878397 2.8904753 2.7515258 0.9257917 3.3239880 0.4693585 4.9146158 ## [9] 0.2296816 3.2920709 4.7342723 4.4256445 0.5334799 1.5910902 4.5501773 3.0226411 ## [17] 0.2046510 3.9737262 1.3052055 2.0850422 ## ## $chain2$log_p10 ## [1] -3.596207 ## ## $chain2$beta ## [1] 0.05520817 ## ## $chain2$q_trans ## initial_values[[i]]$q ## 1 0.7872615 ## ## ## $chain3 ## $chain3$mu_trad_1 ## [1] 4.8505518 4.0163179 0.8375390 3.9024871 4.8707274 4.8644647 4.3380319 1.6399283 ## [9] 4.1358120 4.8363555 1.4619399 1.1389638 4.9408612 1.4267285 3.9601021 4.6860420 ## [17] 1.7089668 0.8324854 1.2504033 0.7275175 ## ## $chain3$mu ## [1] 4.8505518 4.0163179 0.8375390 3.9024871 4.8707274 4.8644647 4.3380319 1.6399283 ## [9] 4.1358120 4.8363555 1.4619399 1.1389638 4.9408612 1.4267285 3.9601021 4.6860420 ## [17] 1.7089668 0.8324854 1.2504033 0.7275175 ## ## $chain3$log_p10 ## [1] -3.799006 ## ## $chain3$beta ## [1] 0.1855994 ## ## $chain3$q_trans ## initial_values[[i]]$q ## 1 0.5643277 ## ## ## $chain4 ## $chain4$mu_trad_1 ## [1] 2.7554272 4.0679301 0.1415597 4.3108366 0.1804336 4.6816822 4.4900137 2.9730838 ## [9] 0.1707672 3.6851893 1.6473768 1.9190297 4.9792169 0.7193204 0.7521687 2.7401448 ## [17] 2.4927889 1.0740960 4.6347019 3.2124127 ## ## $chain4$mu ## [1] 2.7554272 4.0679301 0.1415597 4.3108366 0.1804336 4.6816822 4.4900137 2.9730838 ## [9] 0.1707672 3.6851893 1.6473768 1.9190297 4.9792169 0.7193204 0.7521687 2.7401448 ## [17] 2.4927889 1.0740960 4.6347019 3.2124127 ## ## $chain4$log_p10 ## [1] -2.790357 ## ## $chain4$beta ## [1] 0.1484974 ## ## $chain4$q_trans ## initial_values[[i]]$q ## 1 1.232433 "],["usecase4.html", "Chapter 6 Use case 4: jointModel() with semi-paired data 6.1 Simulate semi-paired data 6.2 Prepare the data 6.3 Fit the model 6.4 Interpret the output 6.5 Initial values", " Chapter 6 Use case 4: jointModel() with semi-paired data This final use case shows how to fit and interpret the joint model with semi-paired eDNA and traditional survey data. In many cases, you may have some sites where only eDNA samples were collected, while other sites have paired eDNA and traditional samples (i.e., semi-paired data). We can fit the joint model to this semi-paired data and use the sites with paired data to make predictions about the sites with only un-paired eDNA data. Let’s use the same tidewater goby data from uses cases 1 and 2, except let’s pretend we did not have traditional seine sampling at two of the 39 sites. 6.1 Simulate semi-paired data Both eDNA and traditional survey data should have a hierarchical structure: Sites (primary sample units) within a study area eDNA and traditional samples (secondary sample units) collected from each site eDNA subsamples (replicate observations) taken from each eDNA sample First replace the traditional count data at sites 4 and 34 with NA to simulate a scenario where we did not have traditional samples at these sites. library(eDNAjoint) data(gobyData) # create new dataset of semi-paired goby data gobyData_semipaired &lt;- gobyData gobyData_semipaired$count[4,] &lt;- NA gobyData_semipaired$count[34,] &lt;- NA We can now see that we have no data at site 4: gobyData_semipaired$count[4,] ## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ## NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA And site 34: gobyData_semipaired$count[34,] ## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ## NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA It’s important to ensure that we replace the data with NA so that we have an empty row indicating missing data. 6.2 Prepare the data Now let’s look at the format of the data. You can see that the data is a list of four matrices all with the same number of rows that represent each site (n=39). Across all matrices, rows in the data should correspond to the same sites (i.e., row one in all matrices corresponds to site one, and row 31 in all matrices corresponds to site 31). qPCR.K, qPCR.N, and count are required for all implementations of jointModel(), and site.cov is optional and is used in use case 2. Let’s look first at qPCR.K. These are the total number of positive qPCR detections for each site (row) and eDNA sample (column). The number of columns should equal the maximum number of eDNA samples collected at any site. Blank spaces are filled with NA at sites where fewer eDNA samples were collected than the maximum. For example, at site one, 11 eDNA samples were collected, and at site five, 20 eDNA samples were collected. head(gobyData_semipaired$qPCR.K) ## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ## [1,] 0 0 0 0 0 0 0 0 0 0 0 NA NA NA NA NA NA NA NA NA NA NA ## [2,] 0 0 0 0 0 0 0 0 0 0 0 NA NA NA NA NA NA NA NA NA NA NA ## [3,] 0 0 0 0 0 0 0 0 0 0 0 NA NA NA NA NA NA NA NA NA NA NA ## [4,] 0 6 6 4 6 5 4 6 5 3 NA NA NA NA NA NA NA NA NA NA NA NA ## [5,] 6 6 4 6 6 6 5 4 2 2 0 6 5 5 6 6 6 5 5 4 NA NA ## [6,] 0 0 0 NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA Now let’s look at qPCR.N. These are the total number of qPCR eDNA subsamples (replicate observations) collected for each site (row) and eDNA sample (column). In this data, six qPCR replicate observations were collected for each eDNA sample. Notice that the locations of the NAs in the matrix match qPCR.K. head(gobyData_semipaired$qPCR.N) ## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ## [1,] 6 6 6 6 6 6 6 6 6 6 6 NA NA NA NA NA NA NA NA NA NA NA ## [2,] 6 6 6 6 6 6 6 6 6 6 6 NA NA NA NA NA NA NA NA NA NA NA ## [3,] 6 6 6 6 6 6 6 6 6 6 6 NA NA NA NA NA NA NA NA NA NA NA ## [4,] 6 6 6 6 6 6 6 6 6 6 NA NA NA NA NA NA NA NA NA NA NA NA ## [5,] 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 NA NA ## [6,] 6 6 6 NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA Next, let’s look at count. This data is from seine sampling for tidewater gobies. Each integer refers to the catch of each seine sample (i.e., catch per unit effort, when effort = 1). Again, the rows correspond to sites, and the columns refer to replicated seine samples (secondary sample units) at each site, with a maximum of 22 samples. Blank spaces are filled with NA at sites where fewer seine samples were collected than the maximum, as well as at sites with no seine samples. Notice that the number of rows (i.e., number of sites) in the count data still equals the number of rows in the qPCR data, even though some of these sites have no count data. dim(gobyData_semipaired$count)[1] == dim(gobyData_semipaired$qPCR.K)[1] ## [1] TRUE For more data formatting guidance, see section 2.1.1. 6.3 Fit the model Now that we understand our data, let’s fit the joint model. The key arguments of this function include: data: list of qPCR.K, qPCR.N, and count matrices family: probability distribution used to model the seine count data. A poisson distribution is chosen here. p10priors: Beta distribution parameters for the prior on the probability of false positive eDNA detection, \\(p_{10}\\). c(1,20) is the default specification. More on this later. q: logical value indicating the presence of multiple traditional gear types. Here, we’re only using data from one traditional method. More parameters exist to further customize the MCMC sampling, but we’ll stick with the defaults. # run the joint model goby.fit.semi &lt;- jointModel(data = gobyData_semipaired, family = &#39;poisson&#39;, p10priors = c(1,20), q=FALSE) goby.fit.semi is a list containing: model fit (goby.fit.semi$model) of the class ‘stanfit’ and can be accessed and interpreted using all functions in the rstan package. initial values used for each chain in MCMC (goby.fit.semi$inits) 6.4 Interpret the output 6.4.1 Summarize posterior distributions Let’s interpret goby.fit.semi. Use jointSummarize() to see the posterior summaries of the model parameters. Let’s look at the estimates of the expected catch rate at each site, \\(\\mu\\). jointSummarize(goby.fit.semi$model, par = &#39;mu&#39;) ## mean se_mean sd 2.5% 97.5% n_eff Rhat ## mu[1] 0.021 0.000 0.021 0.001 0.078 14169.92 1 ## mu[2] 0.021 0.000 0.021 0.001 0.079 14839.58 1 ## mu[3] 0.021 0.000 0.022 0.000 0.080 16158.98 1 ## mu[4] 5.435 0.014 1.767 2.894 9.612 16029.53 1 ## mu[5] 2.431 0.002 0.295 1.897 3.057 16191.08 1 ## mu[6] 0.081 0.001 0.085 0.002 0.307 13810.17 1 ## mu[7] 0.339 0.001 0.105 0.165 0.579 19116.71 1 ## mu[8] 0.276 0.002 0.305 0.007 1.109 15092.18 1 ## mu[9] 0.048 0.000 0.048 0.001 0.177 16823.79 1 ## mu[10] 1.516 0.002 0.207 1.141 1.947 17108.83 1 ## mu[11] 26.957 0.008 1.085 24.872 29.111 20751.52 1 ## mu[12] 0.021 0.000 0.021 0.001 0.077 16743.22 1 ## mu[13] 0.021 0.000 0.021 0.000 0.079 15696.63 1 ## mu[14] 0.033 0.000 0.033 0.001 0.121 15917.98 1 ## mu[15] 0.102 0.000 0.062 0.019 0.254 16244.43 1 ## mu[16] 0.066 0.000 0.049 0.006 0.189 16123.91 1 ## mu[17] 0.026 0.000 0.026 0.001 0.097 15807.08 1 ## mu[18] 0.019 0.000 0.019 0.000 0.072 17119.49 1 ## mu[19] 0.048 0.000 0.049 0.001 0.183 14610.46 1 ## mu[20] 0.224 0.001 0.081 0.095 0.410 20860.72 1 ## mu[21] 0.081 0.001 0.083 0.002 0.306 15697.69 1 ## mu[22] 0.254 0.001 0.114 0.087 0.528 18800.63 1 ## mu[23] 90.565 0.021 3.117 84.648 96.754 22667.21 1 ## mu[24] 1.052 0.002 0.212 0.685 1.510 18046.54 1 ## mu[25] 21.039 0.010 1.629 17.918 24.362 24528.63 1 ## mu[26] 1.287 0.002 0.218 0.910 1.755 19215.62 1 ## mu[27] 2.719 0.003 0.456 1.908 3.685 19551.71 1 ## mu[28] 8.151 0.005 0.757 6.749 9.713 20893.12 1 ## mu[29] 3.227 0.003 0.462 2.396 4.208 18148.44 1 ## mu[30] 13.687 0.014 2.134 9.874 18.181 24813.12 1 ## mu[31] 94.518 0.029 4.347 86.192 103.218 21759.18 1 ## mu[32] 0.023 0.000 0.023 0.001 0.085 15312.38 1 ## mu[33] 0.082 0.001 0.086 0.002 0.316 14540.62 1 ## mu[34] 0.261 0.001 0.143 0.067 0.609 18715.51 1 ## mu[35] 0.127 0.001 0.137 0.003 0.503 15735.29 1 ## mu[36] 0.021 0.000 0.021 0.001 0.078 14314.00 1 ## mu[37] 0.023 0.000 0.023 0.001 0.085 16350.40 1 ## mu[38] 168.973 0.039 5.809 157.732 180.547 21881.17 1 ## mu[39] 0.023 0.000 0.023 0.001 0.088 16771.04 1 This summarizes the mean, sd, and quantiles of the posterior estimates of \\(\\mu\\), as well as the effective sample size (n_eff) and Rhat for the parameters. The model estimates \\(\\beta\\) using data from sites with paired samples and uses this estimate to make predictions for \\(\\mu_{i=4}\\) and \\(\\mu_{i=34}\\) where no traditional seine samples were collected. We can also use functions from the bayesplot package to examine the posterior distributions. First let’s look at the posterior distributions for \\(\\mu_{i=4}\\) and \\(\\mu_{i=29}\\). Traditional seine samples were collected at site 29 but not at site 4. library(bayesplot) # plot posterior distribution, highlighting median and 80% credibility interval mcmc_areas(as.matrix(goby.fit.semi$model), pars = c(&#39;mu[4]&#39;, &#39;mu[29]&#39;), prob = 0.8) As you could expect, the credibility interval for the expected catch rate at site four is much wider than the credibility interval at site 29, since no traditional samples were collected at site four. Let’s do the same for \\(\\mu_{i=7}\\) and \\(\\mu_{i=34}\\). Traditional seine samples were collected at site 7 but not at site 34. # plot posterior distribution, highlighting median and 80% credibility interval mcmc_areas(as.matrix(goby.fit.semi$model), pars = c(&#39;mu[7]&#39;, &#39;mu[34]&#39;), prob = 0.8) Again, the credibility interval for the expected catch rate at site 34 is wider with a longer tail than the credibility interval at site 7, since no traditional samples were collected at site 34. Note: It’s important to consider that fitting the joint model with semi-paired data will be more successful if there is paired data at most sites. Since the data at paired sites is leveraged to make predictions at the un-paired sites, you want to maximize the amount of data to leverage. 6.5 Initial values By default, eDNAjoint will provide initial values for parameters estimated by the model, but you can provide your own initial values if you prefer. Here is an example of providing initial values for parameters, mu,p10, beta, and q, as an input in jointModel(). # set number of chains n.chain &lt;- 4 # initial values should be a list of named lists inits &lt;- list() for(i in 1:n.chain){ inits[[i]] &lt;- list( # length should equal the number of sites (dim(gobyData_semipaired$count)[1]) for each chain mu = stats::runif(dim(gobyData_semipaired$count)[1], 0.01, 5), # length should equal 1 for each chain p10 = stats::runif(1,0.0001,0.08), # length should equal 1 for each chain beta = stats::runif(1,0.05,0.2) ) } # now fit the model fit.w.inits &lt;- jointModel(data = gobyData_semipaired, initial_values = inits) ## ## SAMPLING FOR MODEL &#39;joint_binary_pois&#39; NOW (CHAIN 1). ## Chain 1: ## Chain 1: Gradient evaluation took 0.000513 seconds ## Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 5.13 seconds. ## Chain 1: Adjust your expectations accordingly! ## Chain 1: ## Chain 1: ## Chain 1: Iteration: 1 / 3000 [ 0%] (Warmup) ## Chain 1: Iteration: 500 / 3000 [ 16%] (Warmup) ## Chain 1: Iteration: 501 / 3000 [ 16%] (Sampling) ## Chain 1: Iteration: 1000 / 3000 [ 33%] (Sampling) ## Chain 1: Iteration: 1500 / 3000 [ 50%] (Sampling) ## Chain 1: Iteration: 2000 / 3000 [ 66%] (Sampling) ## Chain 1: Iteration: 2500 / 3000 [ 83%] (Sampling) ## Chain 1: Iteration: 3000 / 3000 [100%] (Sampling) ## Chain 1: ## Chain 1: Elapsed Time: 2.146 seconds (Warm-up) ## Chain 1: 3.909 seconds (Sampling) ## Chain 1: 6.055 seconds (Total) ## Chain 1: ## ## SAMPLING FOR MODEL &#39;joint_binary_pois&#39; NOW (CHAIN 2). ## Chain 2: ## Chain 2: Gradient evaluation took 0.000117 seconds ## Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 1.17 seconds. ## Chain 2: Adjust your expectations accordingly! ## Chain 2: ## Chain 2: ## Chain 2: Iteration: 1 / 3000 [ 0%] (Warmup) ## Chain 2: Iteration: 500 / 3000 [ 16%] (Warmup) ## Chain 2: Iteration: 501 / 3000 [ 16%] (Sampling) ## Chain 2: Iteration: 1000 / 3000 [ 33%] (Sampling) ## Chain 2: Iteration: 1500 / 3000 [ 50%] (Sampling) ## Chain 2: Iteration: 2000 / 3000 [ 66%] (Sampling) ## Chain 2: Iteration: 2500 / 3000 [ 83%] (Sampling) ## Chain 2: Iteration: 3000 / 3000 [100%] (Sampling) ## Chain 2: ## Chain 2: Elapsed Time: 2.155 seconds (Warm-up) ## Chain 2: 5.147 seconds (Sampling) ## Chain 2: 7.302 seconds (Total) ## Chain 2: ## ## SAMPLING FOR MODEL &#39;joint_binary_pois&#39; NOW (CHAIN 3). ## Chain 3: ## Chain 3: Gradient evaluation took 0.000273 seconds ## Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 2.73 seconds. ## Chain 3: Adjust your expectations accordingly! ## Chain 3: ## Chain 3: ## Chain 3: Iteration: 1 / 3000 [ 0%] (Warmup) ## Chain 3: Iteration: 500 / 3000 [ 16%] (Warmup) ## Chain 3: Iteration: 501 / 3000 [ 16%] (Sampling) ## Chain 3: Iteration: 1000 / 3000 [ 33%] (Sampling) ## Chain 3: Iteration: 1500 / 3000 [ 50%] (Sampling) ## Chain 3: Iteration: 2000 / 3000 [ 66%] (Sampling) ## Chain 3: Iteration: 2500 / 3000 [ 83%] (Sampling) ## Chain 3: Iteration: 3000 / 3000 [100%] (Sampling) ## Chain 3: ## Chain 3: Elapsed Time: 2.593 seconds (Warm-up) ## Chain 3: 4.993 seconds (Sampling) ## Chain 3: 7.586 seconds (Total) ## Chain 3: ## ## SAMPLING FOR MODEL &#39;joint_binary_pois&#39; NOW (CHAIN 4). ## Chain 4: ## Chain 4: Gradient evaluation took 0.00015 seconds ## Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 1.5 seconds. ## Chain 4: Adjust your expectations accordingly! ## Chain 4: ## Chain 4: ## Chain 4: Iteration: 1 / 3000 [ 0%] (Warmup) ## Chain 4: Iteration: 500 / 3000 [ 16%] (Warmup) ## Chain 4: Iteration: 501 / 3000 [ 16%] (Sampling) ## Chain 4: Iteration: 1000 / 3000 [ 33%] (Sampling) ## Chain 4: Iteration: 1500 / 3000 [ 50%] (Sampling) ## Chain 4: Iteration: 2000 / 3000 [ 66%] (Sampling) ## Chain 4: Iteration: 2500 / 3000 [ 83%] (Sampling) ## Chain 4: Iteration: 3000 / 3000 [100%] (Sampling) ## Chain 4: ## Chain 4: Elapsed Time: 2.195 seconds (Warm-up) ## Chain 4: 4.07 seconds (Sampling) ## Chain 4: 6.265 seconds (Total) ## Chain 4: ## Refer to the eDNAjoint guide for visualization tips: https://bookdown.org/abigailkeller/eDNAjoint_vignette/tips.html#visualization-tips # check to see the initial values that were used fit.w.inits$inits ## $chain1 ## $chain1$mu_trad ## [1] 3.80569741 3.58333259 4.02588139 0.88034608 2.39102144 2.85321301 3.19553752 ## [8] 4.11689159 4.21357816 0.58820852 0.81208180 4.59726978 2.76241101 1.09808337 ## [15] 1.80897540 0.08415946 0.22912673 3.88901987 1.83084809 4.09662924 3.70403968 ## [22] 2.75512944 0.41795349 3.65420388 0.79756336 1.68574393 1.42799124 0.68656417 ## [29] 4.21855390 1.29522717 3.86613597 1.70403476 3.93140205 3.74998951 4.91692884 ## [36] 2.44362165 1.58280683 ## ## $chain1$mu ## [1] 3.80569741 3.58333259 4.02588139 1.50470175 0.88034608 2.39102144 2.85321301 ## [8] 3.19553752 4.11689159 4.21357816 0.58820852 0.81208180 4.59726978 2.76241101 ## [15] 1.09808337 1.80897540 0.08415946 0.22912673 3.88901987 1.83084809 4.09662924 ## [22] 3.70403968 2.75512944 0.41795349 3.65420388 0.79756336 1.68574393 1.42799124 ## [29] 0.68656417 4.21855390 1.29522717 3.86613597 1.70403476 2.94467392 3.93140205 ## [36] 3.74998951 4.91692884 2.44362165 1.58280683 ## ## $chain1$log_p10 ## [1] -3.343339 ## ## $chain1$beta ## [1] 0.1872188 ## ## ## $chain2 ## $chain2$mu_trad ## [1] 1.5229404 2.5261706 4.5393737 2.5046819 1.7516272 3.2172138 3.2646758 1.6111284 ## [9] 0.1889255 4.0137314 1.8750728 1.7111294 3.2156054 0.1472553 2.9552092 3.8507409 ## [17] 1.9921167 2.2295859 0.8147131 0.7711415 2.5138951 1.6955384 3.4065907 0.1856529 ## [25] 1.3677171 3.8655028 2.6103950 2.6938047 4.7740216 4.0100165 4.3669264 3.7612010 ## [33] 4.0589469 0.8913079 2.0014217 3.5477226 4.4054730 ## ## $chain2$mu ## [1] 1.5229404 2.5261706 4.5393737 1.9139701 2.5046819 1.7516272 3.2172138 3.2646758 ## [9] 1.6111284 0.1889255 4.0137314 1.8750728 1.7111294 3.2156054 0.1472553 2.9552092 ## [17] 3.8507409 1.9921167 2.2295859 0.8147131 0.7711415 2.5138951 1.6955384 3.4065907 ## [25] 0.1856529 1.3677171 3.8655028 2.6103950 2.6938047 4.7740216 4.0100165 4.3669264 ## [33] 3.7612010 3.0359823 4.0589469 0.8913079 2.0014217 3.5477226 4.4054730 ## ## $chain2$log_p10 ## [1] -2.626563 ## ## $chain2$beta ## [1] 0.1768646 ## ## ## $chain3 ## $chain3$mu_trad ## [1] 3.04875278 1.54196188 1.79788661 1.42357885 3.08428369 3.48288864 1.05738581 ## [8] 1.19936314 2.79433858 2.13807436 1.44278498 0.91723819 2.76409730 2.62652365 ## [15] 0.08165406 0.26244407 4.80832827 2.71507669 1.22793599 0.43198037 3.17015670 ## [22] 2.56976175 1.90110157 4.78092426 1.04669546 2.24532204 1.10847388 1.59673621 ## [29] 4.16267811 0.74007828 2.81778891 3.42864284 4.37678259 0.18425663 3.45051921 ## [36] 0.93785434 1.27161283 ## ## $chain3$mu ## [1] 3.04875278 1.54196188 1.79788661 2.59615310 1.42357885 3.08428369 3.48288864 ## [8] 1.05738581 1.19936314 2.79433858 2.13807436 1.44278498 0.91723819 2.76409730 ## [15] 2.62652365 0.08165406 0.26244407 4.80832827 2.71507669 1.22793599 0.43198037 ## [22] 3.17015670 2.56976175 1.90110157 4.78092426 1.04669546 2.24532204 1.10847388 ## [29] 1.59673621 4.16267811 0.74007828 2.81778891 3.42864284 3.60057392 4.37678259 ## [36] 0.18425663 3.45051921 0.93785434 1.27161283 ## ## $chain3$log_p10 ## [1] -2.600622 ## ## $chain3$beta ## [1] 0.1923878 ## ## ## $chain4 ## $chain4$mu_trad ## [1] 2.46700214 4.65893475 1.12654137 3.31605048 0.05295857 2.56674085 2.23751851 ## [8] 4.77927916 2.89327762 0.26356331 2.23214813 2.47137927 3.76330791 1.74409390 ## [15] 1.26386410 3.25034435 0.71165630 4.76585013 0.90427947 1.10725542 4.81844148 ## [22] 4.18821661 2.00013974 3.53148543 3.80450293 1.13242752 2.74157841 1.48478310 ## [29] 4.69588359 2.76480247 3.84184013 4.53443982 3.45898723 2.94703450 1.54455403 ## [36] 1.56655813 0.27269710 ## ## $chain4$mu ## [1] 2.46700214 4.65893475 1.12654137 1.08209782 3.31605048 0.05295857 2.56674085 ## [8] 2.23751851 4.77927916 2.89327762 0.26356331 2.23214813 2.47137927 3.76330791 ## [15] 1.74409390 1.26386410 3.25034435 0.71165630 4.76585013 0.90427947 1.10725542 ## [22] 4.81844148 4.18821661 2.00013974 3.53148543 3.80450293 1.13242752 2.74157841 ## [29] 1.48478310 4.69588359 2.76480247 3.84184013 4.53443982 1.34631350 3.45898723 ## [36] 2.94703450 1.54455403 1.56655813 0.27269710 ## ## $chain4$log_p10 ## [1] -3.167847 ## ## $chain4$beta ## [1] 0.179758 "],["model.html", "Chapter 7 The model 7.1 Model description 7.2 Bayesian modeling: Stan 7.3 Priors", " Chapter 7 The model Below is a representation of the full model used in eDNAjoint, including all model variations. Note that inclusion of gear scaling coefficients, \\(q_k\\) (Eq. 2), and the regression with site-level covariates, \\(\\alpha\\) (Eq. 4), are optional in implementation with eDNAjoint. A reduced version of the joint model without these variations is also described in Keller et al. 2022. 7.1 Model description The observed count, Y, of a species at site, i, in traditional survey sample, j, of gear type, k, is drawn from either a negative binomial distribution with expected species catch rate, \\(\\mu_{i,k}\\), and an overdispersion parameter, \\(\\phi\\) (Equation 1.1) a poisson distribution with expected species catch rate, \\(\\mu_{i,k}\\) (Equation 1.2). A third option allows for repeated continuous observations, Y, of a species at site, i, in traditional survey sample, j, of gear type, k. a gamma distribution with shape parameter, \\(\\alpha_{mu}\\) and rate parameter, \\(\\beta_{mu}\\). The expected species catch rate, \\(\\mu_{i,k}\\) is equal to \\(\\frac{\\alpha_{mu}}{\\beta_{mu}}\\). \\[\\begin{equation} \\tag{Eq. 1.1} Y_{i,j,k} \\sim NegativeBinomial(\\mu_{i,k}, \\phi) \\end{equation}\\] \\[\\begin{equation} \\tag{Eq. 1.2} Y_{i,j,k} \\sim Poisson(\\mu_{i,k}) \\end{equation}\\] \\[\\begin{equation} \\tag{Eq. 1.3} Y_{i,j,k} \\sim Gamma(\\alpha_{mu,i,k}, \\beta_{mu,i,k}) \\end{equation}\\] Gear scaling coefficients, \\(q_k\\), scale the catch rates of multiple gear types relative to gear type 1 (Equation 2). \\[\\begin{equation} \\tag{Eq. 2} \\mu_{i,k} = q_k * \\mu_{i,1} \\end{equation}\\] The probability of a true positive eDNA detection, \\(p_{11}\\), at site i, is a function of expected species catch rate, \\(\\mu_{i,1}\\) and scaling coefficient \\(\\beta_i\\) (Equation 3). \\[\\begin{equation} \\tag{Eq. 3} p_{11,i} = \\frac{\\mu_{i,1}}{\\mu_{i,1} + e^{\\beta_i}} \\end{equation}\\] The scaling coefficient \\(\\beta_i\\) relates the sensitivity of eDNA sampling to the expected species catch rate and is a function of site-level covariate coefficients, \\(\\alpha_n\\) and site-level covariate data, \\(A_{i,n}\\) (Equation 4). \\[\\begin{equation} \\tag{Eq. 4} \\beta_i = A_{i,n}^{T} \\cdot \\alpha_n \\end{equation}\\] The total probability of eDNA detection at site i, \\(p_i\\), is the sum of the probability of a true positive eDNA detection at site i, \\(p_{11,i}\\), and the probability of a false positive eDNA detection, \\(p_{10}\\) (Equation 5). \\[\\begin{equation} \\tag{Eq. 5} p_i = p_{11,i} + p_{10} \\end{equation}\\] The number of positive quantitative PCR (qPCR) eDNA detections, K, out of the number of trials, N, in eDNA water sample m at site i is drawn from a binomial distribution, with a probability of success on a single trial, \\(p_i\\). (Equation 6). \\[\\begin{equation} \\tag{Eq. 6} K_{i,m} \\sim Binomial(N_{i,m}, p_i) \\end{equation}\\] Three informative prior distributions are included in the model for parameters, \\(p_{10}\\), \\(\\alpha_n\\), and \\(\\phi\\) (if a negative binomial distribution is used to describe the traditional survey observations, Eq. 1.2). See below for more details. \\[\\begin{equation} p_{10} \\sim Beta(\\alpha, \\beta) \\end{equation}\\] \\[\\begin{equation} \\phi \\sim Gamma(\\alpha, \\beta) \\end{equation}\\] \\[\\begin{equation} \\alpha_n \\sim Normal(0,10) \\end{equation}\\] 7.2 Bayesian modeling: Stan The models that can be run with eDNAjoint use Bayesian inference for parameter estimation. The models are specified in the probabilistic programming language, Stan, which uses Hamiltonian Monte Carlo to obtain posterior simulations. For this reason, all the models fit using eDNAjoint are of the ‘stanfit’ class and can be analyzed and manipulated with functions in the rstan package, in addition to the functions outlined above. The code for the models written in Stan can be found in this folder of the package Github repo. 7.3 Priors Three non-uniform priors are used in the model. First, there is an informative prior distribution for the false positive probability of eDNA detection, \\(p_{10}\\), which is used for parameter identifiability. A beta distribution is used for the \\(p_{10}\\) prior with two parameters: alpha and beta. Second, an informative prior distribution for the overdispersion parameter, \\(\\phi\\), in the negative binomial distribution for overdispersed count observations (Eq. 1.2). In eDNAjoint, these parameters can be user-specified. The default specification for the \\(p_{10}\\) prior is beta(1,20) (mean: 0.048, var: 0.045), and the default specification for the \\(\\phi\\) prior is gamma(0.25,0.25) (mean: 1, var: 4). Additionally, a normally distributed shrinkage prior is used for \\(\\alpha_n\\), which serves a similar role to regularization. "],["tips.html", "Chapter 8 Tips 8.1 Visualization tips 8.2 Troubleshooting tips", " Chapter 8 Tips 8.1 Visualization tips Running jointModel() with eDNAjoint returns an object of class stanfit and can be accessed and interpreted using all functions in the rstan package. Here are a few examples of how to visualize your MCMC samples. # run the joint model library(eDNAjoint) fit &lt;- jointModel(data = gobyData, family = &#39;poisson&#39;, p10priors = c(1,20), q=FALSE) 8.1.1 Posterior samples We can use the bayesplot package to examine the posterior distributions. First, let’s look at the posterior distribution for \\(p_{10}\\). library(bayesplot) # plot posterior distribution, highlighting median and 80% credibility interval mcmc_areas(as.matrix(fit$model), pars = &#39;p10&#39;, prob = 0.8) We can also look at the posterior distributions of multiple parameters at once using bayesplot: # plot posterior distribution, highlighting median and 90% credibility interval mcmc_areas(as.matrix(fit$model), pars = c(&#39;mu[1]&#39;,&#39;mu[2]&#39;), prob = 0.9) And of course you can always plot the posterior samples using ggplot: library(tidyverse) ggplot()+ geom_histogram(aes(x=as.matrix(fit$model)[,&#39;beta&#39;]))+ labs(x=&#39;beta estimate&#39;, y=&#39;count&#39;)+ theme_minimal() 8.1.2 Chain convergence The bayesplot package can also be used to examine chain convergence for \\(p_{10}\\) and \\(\\mu_{i=1}\\). # this will plot the MCMC chains for p10 and mu at site 1 mcmc_trace(rstan::extract(fit$model, permuted = FALSE), pars = c(&#39;p10&#39;, &#39;mu[1]&#39;)) This plot shows that our chains are well mixed. We can also use ggplot to plot the chains: library(tidyverse) # get chains for param p10 chain1_p10 &lt;- as.array(fit$model)[,&#39;chain:1&#39;,&#39;p10&#39;] chain2_p10 &lt;- as.array(fit$model)[,&#39;chain:2&#39;,&#39;p10&#39;] chain3_p10 &lt;- as.array(fit$model)[,&#39;chain:3&#39;,&#39;p10&#39;] chain4_p10 &lt;- as.array(fit$model)[,&#39;chain:4&#39;,&#39;p10&#39;] ggplot()+ geom_line(aes(x=1:length(chain1_p10), y=chain1_p10), color = &#39;dodgerblue&#39;)+ geom_line(aes(x=1:length(chain2_p10), y=chain2_p10), color = &#39;firebrick&#39;)+ geom_line(aes(x=1:length(chain3_p10), y=chain3_p10), color = &#39;violet&#39;)+ geom_line(aes(x=1:length(chain4_p10), y=chain4_p10), color = &#39;goldenrod&#39;)+ labs(x=&#39;iteration&#39;, y=&#39;p10 estimate&#39;)+ theme_minimal() 8.1.3 Shinystan Shinystan is also a great way to visualize your model fit and diagnose any problems. Here’s how you would use the package: library(shinystan) # launch shiny stan launch_shinystan(fit$model) Note that you will see the log likelihoods and derivative parameters not found in the model description, but you should focus on parameters present in table 1. 8.2 Troubleshooting tips When running jointModel() are your chains not converging? Or are you getting divergent transitions? Here are some tips: 8.2.1 Quick tips Increase the adapt_delta parameter in jointModel(). This governs how big the steps are in the MCMC, so if the steps are too big, then divergent transitions can happen (see more on this here). You could increase this value to something like 0.99 (closer to 1), although this will slow down sampling. Test out different families to describe the data-generating process for the traditional survey data. The default in jointModel() is a poisson distribution, which assumes that the variance equals the mean. Try family = 'negbin', which uses a negative binomial distribution and allows for overdispersed traditional survey data (i.e., variance &gt; mean). Increase the number of burn-in samples with the n.iter.burn parameter in jointModel(). These burn-in samples are the MCMC “warm-up”, so by increasing the length of the warm-up, you could avoid getting divergent transitions during the actual sampling. 8.2.2 Initial values The MCMC algorithm begins sampling at initial values for all the parameters. Sometimes problems can arise if 1) the MCMC starts sampling at parameter values that are far from the true parameter values, which will cause the adaptation to get funky, or 2) if the MCMC starts sampling at parameter values that are invalid, or where the likelihood of the parameter values given the data is 0. Try setting better initial values for the MCMC. For guidance on how to set initial values, refer to the initial values sections for the basic, site-level covariates, multiple gear types, and semi-paired data examples. 8.2.3 Changing priors The model uses a somewhat-informative prior distribution for the false positive probability of an eDNA detection, \\(p_{10}\\). If you are having convergence issues, you can try making this prior more informative. The default prior is p10priors = c(1,20), which describes the beta distribution hyperparameters: alpha, beta. The mean of this distribution is \\(\\frac{\\alpha}{\\alpha + \\beta}\\), and the variance of this distribution is \\(\\frac{\\alpha\\beta}{(\\alpha + \\beta)^2(\\alpha+\\beta+1)}\\). The mean and variance of the default prior is 0.048 and 0.0002, respectively. ggplot()+ geom_histogram(aes(x=rbeta(n=10000, shape1=1, shape2=20)))+ labs(x=&#39;p10 prior&#39;,y=&#39;&#39;)+ theme_minimal() If you wanted to add a more informative prior to reflect your belief that the probability of a false positive eDNA detection is low, you could change these parameter to something like p10prior=c(1,50), where the mean and variance are 0.014 and 0.00019, respectively. ggplot()+ geom_histogram(aes(x=rbeta(n=10000, shape1=1, shape2=70)))+ labs(x=&#39;p10 prior&#39;,y=&#39;&#39;)+ theme_minimal() Put another way, this choice of prior has 97% of its probability density &lt;0.05: pbeta(q=0.05, shape1=1, shape2=70) ## [1] 0.9724163 You can also set this prior using your own data, perhaps from negative controls. For example, let’s say you used 25 negative qPCR controls during eDNA data processing. You can assume that the probability of a false positive is less than \\(\\frac{1}{25} = 0.04\\). To reflect this data, you could create a prior where the probability \\(p_{10}&gt;0.04\\) is low, like p10priors=c(1,100). ggplot()+ geom_histogram(aes(x=rbeta(n=10000, shape1=1, shape2=100)))+ labs(x=&#39;p10 prior&#39;,y=&#39;&#39;)+ theme_minimal() 8.2.4 Adding site-level covariates The model assumes that the site-level mean count and site-level mean eDNA detection rate are generally positively correlated. For example, let’s look at the relationship between the mean count and mean positive eDNA detections in the green crab data. ggplot()+ geom_point(aes(x=rowMeans(greencrabData$count, na.rm=TRUE), y=rowMeans(greencrabData$qPCR.K, na.rm=TRUE)), size=3)+ labs(x=&#39;mean trap count&#39;,y=&#39;mean positive eDNA detections&#39;)+ theme_minimal() Or perhaps let’s look at the goby data, where the mean positive eDNA detections asymptotically approaches the number of eDNA replicates (6) as the site-level mean seine count increases. ggplot()+ geom_point(aes(x=rowMeans(gobyData$count, na.rm=TRUE), y=rowMeans(gobyData$qPCR.K, na.rm=TRUE)), size=3)+ labs(x=&#39;mean seine count&#39;,y=&#39;mean positive eDNA detections&#39;)+ theme_minimal() If your data does not show a similar relationship and is not converging with jointModel(), then consider adding site-level covariates that can explain why the sensitivities between eDNA and traditional sampling do not have the same relationship across all sites. These site-level covariates can be quantitative or categorical (i.e., dummy variables). For example, are some of your sites ponds and others rivers? Is salinity higher at some of your sites? Are some sites particularly turbid? See use case 2 for an example of how to implement jointModel() with site-level covariates. "],["citation.html", "Chapter 9 Citation", " Chapter 9 Citation Using eDNAjoint for a paper you are writing? Consider citing it: Keller A (2024). eDNAjoint: Joint Modeling of Traditional and Environmental DNA Survey Data. R package version 0.2, https://docs.ropensci.org/eDNAjoint/, https://github.com/ropensci/eDNAjoint. "],["references.html", "Chapter 10 References", " Chapter 10 References van Erp, S., Oberski, D.L., Mulder, J. (2019). Shrinkage priors for Bayesian penalized regression. Journal of Mathematical Psychology. 89, 31-50. https://doi.org/10.1016/j.jmp.2018.12.004 Keller, A.G., Grason, E.W., McDonald, P.S., Ramon-Laca, A., Kelly, R.P. (2022). Tracking an invasion front with environmental DNA. Ecological Applications. 32(4): e2561. https://doi.org/10.1002/eap.2561 Schmelzle, M.C. and Kinziger, A.P. (2016). Using occupancy modelling to compare environmental DNA to traditional field methods for regional-scale monitoring of an endangered aquatic species. Molecular Ecology Resources. 16(4): 895-908. https://doi.org/10.1111/1755-0998.12501 Stan Development Team (2023). RStan: the R interface to Stan. R package version 2.21.8. https://mc-stan.org/. Vehtari A, Gabry J, Magnusson M, Yao Y, Bürkner P, Paananen T, Gelman A (2022). “loo: Efficient leave-one-out cross-validation and WAIC for Bayesian models.” R package version 2.5.1, https://mc-stan.org/loo/ Vehtari, A., Gelman, A., Gabry, J. (2017). Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC. Statistics and Computing. 27, 1413-1432. https://doi.org/10.1007/s11222-016-9696-4 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
